<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Salsa</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="mermaid.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="about_salsa.html"><strong aria-hidden="true">1.</strong> About salsa</a></li><li class="chapter-item expanded "><a href="how_to_use.html"><strong aria-hidden="true">2.</strong> How to use Salsa</a></li><li class="chapter-item expanded "><a href="how_salsa_works.html"><strong aria-hidden="true">3.</strong> How Salsa works</a></li><li class="chapter-item expanded "><a href="common_patterns.html"><strong aria-hidden="true">4.</strong> Common patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="common_patterns/selection.html"><strong aria-hidden="true">4.1.</strong> Selection</a></li><li class="chapter-item expanded "><a href="common_patterns/on_demand_inputs.html"><strong aria-hidden="true">4.2.</strong> On-demand (Lazy) inputs</a></li></ol></li><li class="chapter-item expanded "><a href="videos.html"><strong aria-hidden="true">5.</strong> YouTube videos</a></li><li class="chapter-item expanded "><a href="plumbing.html"><strong aria-hidden="true">6.</strong> Plumbing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="plumbing/query_groups.html"><strong aria-hidden="true">6.1.</strong> Query groups</a></li><li class="chapter-item expanded "><a href="plumbing/database.html"><strong aria-hidden="true">6.2.</strong> Database</a></li></ol></li><li class="chapter-item expanded "><a href="rfcs.html"><strong aria-hidden="true">7.</strong> RFCs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rfcs/template.html"><strong aria-hidden="true">7.1.</strong> Template</a></li><li class="chapter-item expanded "><a href="rfcs/RFC0001-Query-Group-Traits.html"><strong aria-hidden="true">7.2.</strong> RFC 0001: Query group traits</a></li><li class="chapter-item expanded "><a href="rfcs/RFC0002-Intern-Queries.html"><strong aria-hidden="true">7.3.</strong> RFC 0002: Intern queries</a></li><li class="chapter-item expanded "><a href="rfcs/RFC0003-Query-Dependencies.html"><strong aria-hidden="true">7.4.</strong> RFC 0003: Query dependencies</a></li><li class="chapter-item expanded "><a href="rfcs/RFC0004-LRU.html"><strong aria-hidden="true">7.5.</strong> RFC 0004: LRU</a></li><li class="chapter-item expanded "><a href="rfcs/RFC0005-Durability.html"><strong aria-hidden="true">7.6.</strong> RFC 0005: Durability</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Salsa</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#about-salsa" id="about-salsa">About salsa</a></h1>
<p>Salsa is a Rust framework for writing incremental, on-demand programs
-- these are programs that want to adapt to changes in their inputs,
continuously producing a new output that is up-to-date. Salsa is based
on the the incremental recompilation techniques that we built for
rustc, and many (but not all) of its users are building compilers or
other similar tooling.</p>
<p>If you'd like to learn more about Salsa, you can check out the
<a href="https://github.com/salsa-rs/salsa/blob/master/examples/hello_world/main.rs">Hello World example</a>
in the repository, or watch some of our <a href="./videos.html">YouTube videos</a>.</p>
<p>If you'd like to chat about Salsa, or you think you might like to
contribute, please jump on to our Zulip instance at
<a href="https://salsa.zulipchat.com/">salsa.zulipchat.com</a>.</p>
<h1><a class="header" href="#how-to-use-salsa" id="how-to-use-salsa">How to use Salsa</a></h1>
<h1><a class="header" href="#how-salsa-works" id="how-salsa-works">How Salsa works</a></h1>
<h2><a class="header" href="#video-available" id="video-available">Video available</a></h2>
<p>To get the most complete introduction to Salsa's inner works, check
out <a href="https://youtu.be/_muY4HjSqVw">the &quot;How Salsa Works&quot; video</a>.  If
you'd like a deeper dive, <a href="https://www.youtube.com/watch?v=i_IhACacPRY">the &quot;Salsa in more depth&quot;
video</a> digs into the
details of the incremental algorithm.</p>
<h2><a class="header" href="#key-idea" id="key-idea">Key idea</a></h2>
<p>The key idea of <code>salsa</code> is that you define your program as a set of
<strong>queries</strong>. Every query is used like function <code>K -&gt; V</code> that maps from
some key of type <code>K</code> to a value of type <code>V</code>. Queries come in two basic
varieties:</p>
<ul>
<li><strong>Inputs</strong>: the base inputs to your system. You can change these
whenever you like.</li>
<li><strong>Functions</strong>: pure functions (no side effects) that transform your
inputs into other values. The results of queries is memoized to
avoid recomputing them a lot. When you make changes to the inputs,
we'll figure out (fairly intelligently) when we can re-use these
memoized values and when we have to recompute them.</li>
</ul>
<h2><a class="header" href="#how-to-use-salsa-in-three-easy-steps" id="how-to-use-salsa-in-three-easy-steps">How to use Salsa in three easy steps</a></h2>
<p>Using salsa is as easy as 1, 2, 3...</p>
<ol>
<li>Define one or more <strong>query groups</strong> that contain the inputs
and queries you will need. We'll start with one such group, but
later on you can use more than one to break up your system into
components (or spread your code across crates).</li>
<li>Define the <strong>query functions</strong> where appropriate.</li>
<li>Define the <strong>database</strong>, which contains the storage for all
the inputs/queries you will be using. The query struct will contain
the storage for all of the inputs/queries and may also contain
anything else that your code needs (e.g., configuration data).</li>
</ol>
<p>To see an example of this in action, check out <a href="https://github.com/salsa-rs/salsa/blob/master/examples/hello_world/main.rs">the <code>hello_world</code>
example</a>, which has a number of comments explaining how
things work.</p>
<h1><a class="header" href="#common-patterns" id="common-patterns">Common patterns</a></h1>
<p>This section documents patterns for using Salsa.</p>
<h1><a class="header" href="#selection" id="selection">Selection</a></h1>
<p>The &quot;selection&quot; (or &quot;firewall&quot;) pattern is when you have a query Qsel that reads from some
other Qbase and extracts some small bit of information from Qbase that it returns.
In particular, Qsel does not combine values from other queries. In some sense,
then, Qsel is redundant -- you could have just extracted the information
the information from Qbase yourself, and done without the salsa machinery. But
Qsel serves a role in that it limits the amount of re-execution that is required
when Qbase changes.</p>
<h2><a class="header" href="#example-the-base-query" id="example-the-base-query">Example: the base query</a></h2>
<p>For example, imagine that you have a query <code>parse</code> that parses the input text of a request
and returns a <code>ParsedResult</code>, which contains a header and a body:</p>
<pre><code class="language-rust ignore">#[derive(Clone, Debug, PartialEq, Eq)]
struct ParsedResult {
    header: Vec&lt;ParsedHeader&gt;,
    body: String,
}

#[derive(Clone, Debug, PartialEq, Eq)]
struct ParsedHeader {
    key: String,
    value: String,
}

#[salsa::query_group(Request)]
trait RequestParser {
    /// The base text of the request.
    #[salsa::input]
    fn request_text(&amp;self) -&gt; String;

    /// The parsed form of the request.
    fn parse(&amp;self) -&gt; ParsedResult;
} 
</code></pre>
<h2><a class="header" href="#example-a-selecting-query" id="example-a-selecting-query">Example: a selecting query</a></h2>
<p>And now you have a number of derived queries that only look at the header.
For example, one might extract the &quot;content-type' header:</p>
<pre><code class="language-rust ignore">#[salsa::query_group(Request)]
trait RequestUtil: RequestParser {
    fn content_type(&amp;self) -&gt; Option&lt;String&gt;;
}

fn content_type(db: &amp;impl RequestUtil) -&gt; Option&lt;String&gt; {
    db.parse()
        .header
        .iter()
        .find(|header| header.key == &quot;content-type&quot;)
        .map(|header| header.value.clone())
} 
</code></pre>
<h2><a class="header" href="#why-prefer-a-selecting-query" id="why-prefer-a-selecting-query">Why prefer a selecting query?</a></h2>
<p>This <code>content_type</code> query is an instance of the <em>selection</em> pattern. It only
&quot;selects&quot; a small bit of information from the <code>ParsedResult</code>. You might not have
made it a query at all, but instead made it a method on <code>ParsedResult</code>.</p>
<p>But using a query for <code>content_type</code> has an advantage: now if there are downstream
queries that only depend on the <code>content_type</code> (or perhaps on other headers extracted
via a similar pattern), those queries will not have to be re-executed when the request
changes <em>unless</em> the content-type header changes. Consider the dependency graph:</p>
<pre><code class="language-text">request_text  --&gt;  parse  --&gt;  content_type  --&gt;  (other queries)
</code></pre>
<p>When the <code>request_text</code> changes, we are always going to have to re-execute <code>parse</code>.
If that produces a new parsed result, we are <em>also</em> going to re-execute <code>content_type</code>.
But if the result of <code>content_type</code> has not changed, then we will <em>not</em> re-execute
the other queries.</p>
<h2><a class="header" href="#more-levels-of-selection" id="more-levels-of-selection">More levels of selection</a></h2>
<p>In fact, in our example we might consider introducing another level of selection.
Instead of having <code>content_type</code> directly access the results of <code>parse</code>, it might be better
to insert a selecting query that just extracts the header:</p>
<pre><code class="language-rust ignore">#[salsa::query_group(Request)]
trait RequestUtil: RequestParser {
    fn header(&amp;self) -&gt; Vec&lt;ParsedHeader&gt;;
    fn content_type(&amp;self) -&gt; Option&lt;String&gt;;
}

fn header(db: &amp;impl RequestUtil) -&gt; Vec&lt;ParsedHeader&gt; {
    db.parse().header.clone()
}

fn content_type(db: &amp;impl RequestUtil) -&gt; Option&lt;String&gt; {
    db.header()
        .iter()
        .find(|header| header.key == &quot;content-type&quot;)
        .map(|header| header.value.clone())
} 
</code></pre>
<p>This will result in a dependency graph like so:</p>
<pre><code class="language-text">request_text  --&gt;  parse  --&gt;  header --&gt;  content_type  --&gt;  (other queries)
</code></pre>
<p>The advantage of this is that changes that only effect the &quot;body&quot; or
only consume small parts of the request will
not require us to re-execute <code>content_type</code> at all. This would be particularly
valuable if there are a lot of dependent headers.</p>
<h2><a class="header" href="#a-note-on-cloning-and-efficiency" id="a-note-on-cloning-and-efficiency">A note on cloning and efficiency</a></h2>
<p>In this example, we used common Rust types like <code>Vec</code> and <code>String</code>,
and we cloned them quite frequently. This will work just fine in Salsa,
but it may not be the most efficient choice. This is because each clone
is going to produce a deep copy of the result. As a simple fix, you
might convert your data structures to use <code>Arc</code> (e.g., <code>Arc&lt;Vec&lt;ParsedHeader&gt;&gt;</code>),
which makes cloning cheap.</p>
<h1><a class="header" href="#on-demand-lazy-inputs" id="on-demand-lazy-inputs">On-Demand (Lazy) Inputs</a></h1>
<p>Salsa input queries work best if you can easily provide all of the inputs upfront.
However sometimes the set of inputs is not known beforehand.</p>
<p>A typical example is reading files from disk.
While it is possible to eagerly scan a particular directory and create an in-memory file tree in a salsa input query, a more straight-forward approach is to read the files lazily.
That is, when someone requests the text of a file for the first time:</p>
<ol>
<li>Read the file from disk and cache it.</li>
<li>Setup a file-system watcher for this path.</li>
<li>Invalidate the cached file once the watcher sends a change notification.</li>
</ol>
<p>This is possible to achieve in salsa, using a derived query and <code>report_synthetic_read</code> and <code>invalidate</code> queries.
The setup looks roughly like this:</p>
<pre><code class="language-rust ignore">#[salsa::query_group(VfsDatabaseStorage)]
trait VfsDatabase: salsa::Database + FileWatcher {
    fn read(&amp;self, path: PathBuf) -&gt; String;
}

trait FileWatcher {
    fn watch(&amp;self, path: &amp;Path);
    fn did_change_file(&amp;mut self, path: &amp;Path);
}

fn read(db: &amp;impl salsa::Database, path: PathBuf) -&gt; String {
    db.salsa_runtime()
        .report_synthetic_read(salsa::Durability::LOW);
    db.watch(&amp;path);
    std::fs::read_to_string(&amp;path).unwrap_or_default()
}

#[salsa::database(VfsDatabaseStorage)]
struct MyDatabase { ... }

impl FileWatcher for MyDatabase {
    fn watch(&amp;self, path: &amp;Path) { ... }
    fn did_change_file(&amp;mut self, path: &amp;Path) {
        self.query_mut(ReadQuery).invalidate(path);
    }
}
</code></pre>
<ul>
<li>We declare the query as a derived query (which is the default).</li>
<li>In the query implementation, we don't call any other query and just directly read file from disk.</li>
<li>Because the query doesn't read any inputs, it will be assigned a <code>HIGH</code> durability by default, which we override with <code>report_synthetic_read</code>.</li>
<li>The result of the query is cached, and we must call <code>invalidate</code> to clear this cache.</li>
</ul>
<h1><a class="header" href="#youtube-videos" id="youtube-videos">YouTube videos</a></h1>
<p>There are currently two videos about Salsa available:</p>
<ul>
<li><a href="https://youtu.be/_muY4HjSqVw">How Salsa Works</a>, which gives a
high-level introduction to the key concepts involved and shows how
to use salsa;</li>
<li><a href="https://www.youtube.com/watch?v=i_IhACacPRY">Salsa In More Depth</a>,
which digs into the incremental algorithm and explains -- at a
high-level -- how Salsa is implemented.</li>
</ul>
<h1><a class="header" href="#plumbing" id="plumbing">Plumbing</a></h1>
<p><strong>Last updated:</strong> 2020-06-24</p>
<p>This chapter documents the code that salsa generates and its &quot;inner workings&quot;.
We refer to this as the &quot;plumbing&quot;.</p>
<p>This page walks through the <a href="https://github.com/salsa-rs/salsa/blob/master/examples/hello_world/main.rs">&quot;Hello, World!&quot;</a> example and explains the code that
it generates. Please take it with a grain of salt: while we make an effort to
keep this documentation up to date, this sort of thing can fall out of date
easily.</p>
<p>If you'd like to see for yourself, you can set the environment variable
<code>SALSA_DUMP</code> to 1 while the procedural macro runs, and it will dump the full
output to stdout. I recommend piping the output through rustfmt.</p>
<h1><a class="header" href="#query-groups-and-query-group-structs" id="query-groups-and-query-group-structs">Query groups and query group structs</a></h1>
<p>When you define a query group trait:</p>
<pre><code class="language-rust ignore">#[salsa::query_group(HelloWorldStorage)]
trait HelloWorld: salsa::Database {
    // For each query, we give the name, some input keys (here, we
    // have one key, `()`) and the output type `Arc&lt;String&gt;`. We can
    // use attributes to give other configuration:
    //
    // - `salsa::input` indicates that this is an &quot;input&quot; to the system,
    //   which must be explicitly set. The `salsa::query_group` method
    //   will autogenerate a `set_input_string` method that can be
    //   used to set the input.
    #[salsa::input]
    fn input_string(&amp;self, key: ()) -&gt; Arc&lt;String&gt;;

    // This is a *derived query*, meaning its value is specified by
    // a function (see Step 2, below).
    fn length(&amp;self, key: ()) -&gt; usize;
}
</code></pre>
<p>the <code>salsa::query_group</code> macro generates a number of things:</p>
<ul>
<li>a copy of the <code>HelloWorld</code> trait, minus the salsa annotations, and lightly edited</li>
<li>a &quot;group struct&quot; named <code>HelloWorldStorage</code> that represents the group; this struct implements <code>plumbing::QueryGroup</code>
<ul>
<li>somewhat confusingly, this struct doesn't actually contain the storage itself, but rather has an associated type that leads to the &quot;true&quot; storage struct</li>
</ul>
</li>
<li>an impl of the <code>HelloWorld</code> trait, for any database type</li>
<li>for each query, a &quot;query struct&quot; named after the query; these structs implement <code>plumbing::Query</code> and sometimes other plumbing traits</li>
<li>a group key, an enum that can identify any query within the group and store its key</li>
<li>the associated storage struct, which contains the actual hashmaps that store the data for all queries in the group</li>
</ul>
<p>Note that there are a number of structs and types (e.g., the group descriptor
and associated storage struct) that represent things which don't have &quot;public&quot;
names. We currently generate mangled names with <code>__</code> afterwards, but those names
are not meant to be exposed to the user (ideally we'd use hygiene to enforce
this).</p>
<p>So the generated code looks something like this. We'll go into more detail on
each part in the following sections.</p>
<pre><code class="language-rust ignore">// First, a copy of the trait, though sometimes with some extra
// methods (e.g., `set_input_string`)
trait HelloWorld: salsa::Database {
    fn input_string(&amp;self, key: ()) -&gt; Arc&lt;String&gt;;
    fn set_input_string(&amp;mut self, key: (), value: Arc&lt;String&gt;);
    fn length(&amp;self, key: ()) -&gt; usize;
}

// Next, the group struct
struct HelloWorldStorage { }
impl&lt;DB&gt; salsa::plumbing::QueryGroup&lt;DB&gt; for HelloWorldStorage { ... }

// Next, the impl of the trait
impl&lt;DB&gt; HelloWorld for DB
where
  DB: salsa::Database,
  DB: salsa::plumbing::HasQueryGroup&lt;HelloWorldStorage&gt;,
{
  ...
}

// Next, a series of query structs and query impls
struct InputQuery { }
unsafe impl&lt;DB&gt; salsa::Query&lt;DB&gt; for InputQuery
where
    DB: HelloWorld,
    DB: salsa::plumbing::HasQueryGroup&lt;#group_struct&gt;,
    DB: salsa::Database,
{
    ...
}
struct LengthQuery { }
unsafe impl&lt;DB&gt; salsa::Query&lt;DB&gt; for LengthQuery
where
    DB: HelloWorld,
    DB: salsa::plumbing::HasQueryGroup&lt;#group_struct&gt;,
    DB: salsa::Database,
{
    ...
}

// For derived queries, those include implementations
// of additional traits like `QueryFunction`
unsafe impl&lt;DB&gt; salsa::QueryFunction&lt;DB&gt; for LengthQuery
where
    DB: HelloWorld,
    DB: salsa::plumbing::HasQueryGroup&lt;#group_struct&gt;,
    DB: salsa::Database,
{
    ...
}

// The group key
enum HelloWorldGroupKey__ { .. }

// The group storage
struct HelloWorldGroupStorage__ { .. }
</code></pre>
<h2><a class="header" href="#the-group-struct-and-querygroup-trait" id="the-group-struct-and-querygroup-trait">The group struct and <code>QueryGroup</code> trait</a></h2>
<p>The group struct is the only thing we generate whose name is known to the user.
For a query group named <code>Foo</code>, it is conventionally called <code>FooStorage</code>, hence
the name <code>HelloWorldStorage</code> in our example.</p>
<p>Despite the name &quot;Storage&quot;, the struct itself has no fields. It exists only to
implement the <code>QueryGroup</code> trait. This <em>trait</em> has a number of associated types
that reference various bits of the query group, including the actual &quot;group
storage&quot; struct:</p>
<pre><code class="language-rust ignore">struct HelloWorldStorage { }
impl&lt;DB&gt; salsa::plumbing::QueryGroup&lt;DB&gt; for HelloWorldStorage {
    type GroupStorage = HelloWorldGroupStorage__; // generated struct
    type GroupKey = HelloWorldGroupKey__;
    type GroupData = ((), Arc&lt;String&gt;, (), usize);
}
</code></pre>
<p>We'll go into detail on these types below and the role they play, but one that
we didn't mention yet is <code>GroupData</code>. That is a kind of hack used to manage
send/sync around slots, and it gets covered in the section on slots.</p>
<h2><a class="header" href="#impl-of-the-hello-world-trait" id="impl-of-the-hello-world-trait">Impl of the hello world trait</a></h2>
<p>Ultimately, every salsa query group is going to be implemented by your final
database type, which is not currently known to us (it is created by combining
multiple salsa query groups). In fact, this salsa query group could be composed
into multiple database types. However, we want to generate the impl of the query-group
trait here in this crate, because this is the point where the trait definition is visible
and known to us (otherwise, we'd have to duplicate the method definitions).</p>
<p>So what we do is that we define a different trait, called <code>plumbing::HasQueryGroup&lt;G&gt;</code>,
that can be implemented by the database type. <code>HasQueryGroup</code> is generic over
the query group struct. So then we can provide an impl of <code>HelloWorld</code> for any
database type <code>DB</code> where <code>DB: HasQueryGroup&lt;HelloWorldStorage&gt;</code>. This
<code>HasQueryGroup</code> defines a few methods that, given a <code>DB</code>, give access to the
data for the query group and a few other things.</p>
<p>Thus we can generate an impl that looks like:</p>
<pre><code class="language-rust ignore">impl&lt;DB&gt; HelloWorld for DB
where
    DB: salsa::Database,
    DB: salsa::plumbing::HasQueryGroup&lt;HelloWorld&gt;
{
    ...
    fn length(&amp;self, key: ()) -&gt; Arc&lt;String&gt; {
      &lt;Self as salsa::plumbing::GetQueryTable&lt;HelloWorldLength__&gt;&gt;::get_query_table(self).get(())
    }
}
</code></pre>
<p>You can see that the various methods just hook into generic functions in the
<code>salsa::plumbing</code> module. These functions are generic over the query types
(<code>HelloWorldLength__</code>) that will be described shortly. The details of the &quot;query
table&quot; are covered in a future section, but in short this code pulls out the
hasmap for storing the <code>length</code> results and invokes the generic salsa logic to
check for a valid result, etc.</p>
<h2><a class="header" href="#for-each-query-a-query-struct" id="for-each-query-a-query-struct">For each query, a query struct</a></h2>
<p>As we referenced in the previous section, each query in the trait gets a struct
that represents it. This struct is named after the query, converted into snake
case and with the word <code>Query</code> appended. In typical Salsa workflows, these
structs are not meant to be named or used, but in some cases it may be required.
For e.g. the <code>length</code> query, this structs might look something like:</p>
<pre><code class="language-rust ignore">struct LengthQuery { }
</code></pre>
<p>The struct also implements the <code>plumbing::Query</code> trait, which defines
a bunch of metadata about the query (and repeats, for convenience,
some of the data about the group that the query is in):</p>
<pre><code class="language-rust ignore">unsafe impl&lt;DB&gt; salsa::Query&lt;DB&gt; for LengthQuery
where
    DB: HelloWorld,
    DB: salsa::plumbing::HasQueryGroup&lt;#group_struct&gt;,
    DB: salsa::Database,
{
    // A tuple of the types of the function parameters trom trait.
    type Key = ((), );

    // The return value of the function in the trait.
    type Value = Arc&lt;String&gt;;

    // The &quot;query storage&quot; references a type from within salsa
    // that stores the actual query data and defines the
    // logic for accessing and revalidating it.
    //
    // It is generic over the query type which lets it
    // customize itself to the keys/value of this particular
    // query.
    type Storage = salsa::derived::DerivedStorage&lt;
        DB,
        LengthQuery,
        salsa::plumbing::MemoizedStorage,
    &gt;;

    // Types from the query group, repeated for convenience.
    type Group = HelloWorldStorage;
    type GroupStorage = HelloWorldGroupStorage__;
    type GroupKey = HelloWorldGroupKey__;

    // Given the storage for the entire group, extract
    // the storage for just this query. Described when
    // we talk about group storage.
    fn query_storage(
        group_storage: &amp;HelloWorldGroupStorage__,
    ) -&gt; &amp;std::sync::Arc&lt;Self::Storage&gt; {
        &amp;group_storage.length
    }

    // Given the key for this query, construct the &quot;group key&quot;
    // that situates it within the group. Described when
    // we talk about group key.
    fn group_key(key: Self::Key) -&gt; Self::GroupKey {
        HelloWorldGroupKey__::length(key)
    }
}
</code></pre>
<p>Depending on the kind of query, we may also generate other impls, such as an
impl of <code>salsa::plumbing::QueryFunction</code>, which defines the methods for
executing the body of a query. This impl would then include a call to the user's
actual function.</p>
<h2><a class="header" href="#group-key" id="group-key">Group key</a></h2>
<p>The &quot;query key&quot; is the inputs to the query, and identifies a particular query
instace: in our example, it is a value of type <code>()</code> (so there is only one
instance of the query), but typically it's some other type. The &quot;group key&quot; then
broadens that to include the identifier of the query within the group. So instead
of just <code>()</code> the group key would encode (e.g.) <code>Length(())</code> (the &quot;length&quot; query
applied to the <code>()</code> key). It is represented as an enum, which we generate,
with one variant per query:</p>
<pre><code class="language-rust ignore">#[derive(Clone, Debug, PartialEq, Eq, Hash)]
enum HelloWorldGroupKey__ {
  input(()),
  length(()),
}
</code></pre>
<p>The <code>Query</code> trait that we saw earlier includes a method <code>group_key</code> for wrapping
the key for some individual query into the group key.</p>
<h2><a class="header" href="#group-storage" id="group-storage">Group storage</a></h2>
<p>The &quot;group storage&quot; is the actual struct that contains all the hashtables and
so forth for each query. The types of these are ultimately defined by the
<code>Storage</code> associated type for each query type. The struct is generic over the
final database type:</p>
<pre><code class="language-rust ignore">struct HelloWorldGroupStorage__&lt;DB&gt; {
    input: &lt;InputQuery as Query&lt;DB&gt;&gt;::Storage,
    length: &lt;LengthQuery as Query&lt;DB&gt;&gt;::Storage,
}
</code></pre>
<p>We also generate some impls: first is an impl of <code>Default</code> and the second is a
method <code>for_each_query</code> that simply iterates over each field and invokes a
method on it. This method is called by some of the code we generate for the
database in order to implement debugging methods that &quot;sweep&quot; over all the
queries.</p>
<pre><code class="language-rust ignore">impl&lt;DB&gt; HelloWorldGroupStorage__&lt;DB&gt; {
    fn for_each_query(&amp;self, db: &amp;DB, method: &amp;mut dyn FnMut(...)) {
        ...
    }
}
</code></pre>
<h1><a class="header" href="#database" id="database">Database</a></h1>
<p>Continuing our dissection, the other thing which a user must define is a
<strong>database</strong>, which looks something like this:</p>
<pre><code class="language-rust ignore">#[salsa::database(HelloWorldStorage)]
#[derive(Default)]
struct DatabaseStruct {
    runtime: salsa::Runtime&lt;DatabaseStruct&gt;,
}

// Tell salsa where to find the runtime in your context.
impl salsa::Database for DatabaseStruct {
    fn salsa_runtime(&amp;self) -&gt; &amp;salsa::Runtime&lt;Self&gt; {
        &amp;self.runtime
    }

    fn salsa_runtime_mut(&amp;mut self) -&gt; &amp;mut salsa::Runtime&lt;Self&gt; {
        &amp;mut self.runtime
    }
}
</code></pre>
<p>The <code>salsa::database</code> procedural macro takes a list of query group
structs (like <code>HelloWorldStorage</code>) and generates the following items:</p>
<ul>
<li>a copy of the database struct it is applied to</li>
<li>a struct <code>__SalsaDatabaseStorage</code> that contains all the storage structs for
each query group. Note: these are the structs full of hashmaps etc that are
generaetd by the query group procdural macro, not the <code>HelloWorldStorage</code>
struct itself.</li>
<li>a struct <code>__SalsaDatabaseKey</code> that wraps an enum <code>__SalsaDatabaseKeyKind</code>. The
enum contains one variant per query group, and in each variant contains the
group key. This can be used to identify any query in the database.</li>
<li>an impl of <code>HasQueryGroup&lt;G&gt;</code> for each query group <code>G</code></li>
<li>an impl of <code>salsa::plumbing::DatabaseStorageTypes</code> for the database struct</li>
<li>an impl of <code>salsa::plumbing::DatabaseOps</code> for the database struct</li>
<li>an impl of <code>salsa::plumbing::DatabaseKey&lt;DB&gt;</code> for the database struct <code>DB</code></li>
</ul>
<h2><a class="header" href="#key-constraint-we-do-not-know-the-names-of-individual-queries" id="key-constraint-we-do-not-know-the-names-of-individual-queries">Key constraint: we do not know the names of individual queries</a></h2>
<p>There is one key constraint in the design here. None of this code knows the
names of individual queries. It only knows the name of the query group storage
struct. This means that we often delegate things to the group -- e.g., the
database key is composed of group keys. This is similar to how none of the code
in the query group knows the full set of query groups, and so it must use
associated types from the <code>Database</code> trait whenever it needs to put something in
a &quot;global&quot; context.</p>
<h2><a class="header" href="#the-database-storage-struct" id="the-database-storage-struct">The database storage struct</a></h2>
<p>The <code>__SalsaDatabaseStorage</code> struct concatenates all of the query group storage
structs. In the hello world example, it looks something like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct __SalsaDatabaseStorage {
    hello_world: &lt;HelloWorldStorage as salsa::plumbing::QueryGroup&lt;DatabaseStruct&gt;&gt;::GroupStorage
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#the-database-key-struct--enum-and-the-databasekey-impl" id="the-database-key-struct--enum-and-the-databasekey-impl">The database key struct / enum and the <code>DatabaseKey</code> impl</a></h2>
<p>The <code>__SalsaDatabaseKey</code> and <code>__SalsaDatabaseKeyKind</code> types create a <strong>database
key</strong>, which uniquely identifies any query in the database. It builds on the
<strong>group keys</strong> created by the query groups, which uniquely identify a query
within a given query group.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct __SalsaDatabaseKey {
    kind: __SalsaDatabaseKeyKind
}

enum __SalsaDatabaseKeyKind {
    HelloWorld(
        &lt;HelloWorldStorage as salsa::plumbing::QueryGroup&lt;DatabaseStruct&gt;&gt;::GroupKey
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>We also generate an impl of <code>DatabaseKey</code>:</p>
<pre><code class="language-rust ignore">    output.extend(quote! {
        impl salsa::plumbing::DatabaseKey&lt;#database_name&gt; for __SalsaDatabaseKey {
        }
    });
</code></pre>
<h2><a class="header" href="#the-hasquerygroup-impl" id="the-hasquerygroup-impl">The <code>HasQueryGroup</code> impl</a></h2>
<p>The <code>HasQueryGroup</code> trait allows a given query group to access its definition
within the greater database. The impl is generated here:</p>
<pre><code class="language-rust ignore">        has_group_impls.extend(quote! {
            impl salsa::plumbing::HasQueryGroup&lt;#group_path&gt; for #database_name {
                fn group_storage(db: &amp;Self) -&gt; &amp;#group_storage {
                    let runtime = salsa::Database::salsa_runtime(db);
                    &amp;runtime.storage().#group_name_snake
                }

                fn database_key(group_key: #group_key) -&gt; __SalsaDatabaseKey {
                    __SalsaDatabaseKey {
                        kind: __SalsaDatabaseKeyKind::#group_name(group_key),
                    }
                }
            }
        });
</code></pre>
<p>and so for our example it would look something like</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl salsa::plumbing::HasQueryGroup&lt;HelloWorld&gt; for DatabaseStruct {
    fn group_storage(&amp;self) -&gt; &amp;HelloWorldStorage::GroupStorage {
        &amp;self.hello_world
    }

    fn database_key(group_key: HelloWorldStorage::GroupKey) -&gt; __SalsaDatabaseKey {
        __SalsaDatabaseKey {
            kind: __SalsaDatabaseKeyKind::HelloWorld(group_key)
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#other-impls" id="other-impls">Other impls</a></h2>
<p>Then there are a variety of other impls, like this one for <code>DatabaseStorageTypes</code>:</p>
<pre><code class="language-rust ignore">    output.extend(quote! {
        impl salsa::plumbing::DatabaseStorageTypes for #database_name {
            type DatabaseKey = __SalsaDatabaseKey;
            type DatabaseStorage = __SalsaDatabaseStorage;
            type DatabaseData = (#(#database_data),*);
        }
    });
</code></pre>
<p>Or this one for <code>DatabaseOps</code>, which defines the for-each method to
invoke an operation on every kind of query in the database. It ultimately
delegates to the <code>for_each</code> methods for the groups:</p>
<pre><code class="language-rust ignore">    let mut for_each_ops = proc_macro2::TokenStream::new();
    for (QueryGroup { group_path }, group_storage) in
        query_groups.iter().zip(&amp;query_group_storage_names)
    {
        for_each_ops.extend(quote! {
            let storage: &amp;#group_storage =
                &lt;Self as salsa::plumbing::HasQueryGroup&lt;#group_path&gt;&gt;::group_storage(self);
            storage.for_each_query(self, &amp;mut op);
        });
    }
    output.extend(quote! {
        impl salsa::plumbing::DatabaseOps for #database_name {
            fn for_each_query(
                &amp;self,
                mut op: impl FnMut(&amp;dyn salsa::plumbing::QueryStorageMassOps&lt;Self&gt;),
            ) {
<span class="boring">                for_each_ops
</span>            }
        }
    });
</code></pre>
<h1><a class="header" href="#rfcs" id="rfcs">RFCs</a></h1>
<p>The Salsa RFC process is used to describe the motivations for major changes made
to Salsa. RFCs are recorded here in the Salsa book as a historical record of the
considerations that were raised at the time. Note that the contents of RFCs,
once merged, is typically not updated to match further changes. Instead, the
rest of the book is updated to include the RFC text and then kept up to
date as more PRs land and so forth.</p>
<h2><a class="header" href="#creating-an-rfc" id="creating-an-rfc">Creating an RFC</a></h2>
<p>If you'd like to propose a major new Salsa feature, simply clone the repository
and create a new chapter under the list of RFCs based on the <a href="./rfcs/template.html">RFC template</a>.
Then open a PR with a subject line that starts with &quot;RFC:&quot;.</p>
<h2><a class="header" href="#rfc-vs-implementation" id="rfc-vs-implementation">RFC vs Implementation</a></h2>
<p>The RFC can be in its own PR, or it can also includ work on the implementation
together, whatever works best for you.</p>
<h2><a class="header" href="#does-my-change-need-an-rfc" id="does-my-change-need-an-rfc">Does my change need an RFC?</a></h2>
<p>Not all PRs require RFCs. RFCs are only needed for larger features or major
changes to how Salsa works. And they don't have to be super complicated, but
they should capture the most important reasons you would like to make the
change. When in doubt, it's ok to just open a PR, and we can always request an
RFC if we want one.</p>
<h1><a class="header" href="#summary" id="summary">Summary</a></h1>
<p>Summarize the effects of the RFC bullet point form.</p>
<h1><a class="header" href="#motivation" id="motivation">Motivation</a></h1>
<p>Say something about your goals here.</p>
<h1><a class="header" href="#users-guide" id="users-guide">User's guide</a></h1>
<p>Describe effects on end users here.</p>
<h1><a class="header" href="#reference-guide" id="reference-guide">Reference guide</a></h1>
<p>Describe implementation details or other things here.</p>
<h1><a class="header" href="#alternatives-and-future-work" id="alternatives-and-future-work">Alternatives and future work</a></h1>
<p>Various downsides, rejected approaches, or other considerations.</p>
<h1><a class="header" href="#motivation-1" id="motivation-1">Motivation</a></h1>
<ul>
<li>Support <code>dyn QueryGroup</code> for each query group trait as well as <code>impl QueryGroup</code>
<ul>
<li><code>dyn QueryGroup</code> will be much more convenient, at the cost of runtime efficiency</li>
</ul>
</li>
<li>Don't require you to redeclare each query in the final database, just the query groups</li>
</ul>
<h1><a class="header" href="#users-guide-1" id="users-guide-1">User's guide</a></h1>
<h2><a class="header" href="#declaring-a-query-group" id="declaring-a-query-group">Declaring a query group</a></h2>
<p>User's will declare query groups by decorating a trait with <code>salsa::query_group</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[salsa::query_group(MyGroupStorage)]
trait MyGroup {
  // Inputs are annotated with `#[salsa::input]`. For inputs, the final trait will include
  // a `set_my_input(&amp;mut self, key: K1, value: V1)` method automatically added,
  // as well as possibly other mutation methods.
  #[salsa::input]
  fn my_input(&amp;self, key: K1) -&gt; V1;
  
  // &quot;Derived&quot; queries are just a getter.
  fn my_query(&amp;self, key: K2) -&gt; V2;
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>query_group</code> attribute is a procedural macro. It takes as
argument the name of the <strong>storage struct</strong> for the query group --
this is a struct, generated by the macro, which represents the query
group as a whole. It is attached to a trait definition which defines the
individual queries in the query group.</p>
<p>The macro generates three things that users interact with:</p>
<ul>
<li>the trait, here named <code>MyGroup</code>. This will be used when writing the definitions
for the queries and other code that invokes them.</li>
<li>the storage struct, here named <code>MyGroupStorage</code>. This will be used later when
constructing the final database.</li>
<li>query structs, named after each query but converted to camel-case
and with the word query (e.g., <code>MyInputQuery</code> for <code>my_input</code>). These
types are rarely needed, but are presently useful for things like
invoking the GC. These types violate our rule that &quot;things the user
needs to name should be given names by the user&quot;, but we choose not
to fully resolve this question in this RFC.</li>
</ul>
<p>In addition, the macro generates a number of structs that users should
not have to be aware of. These are described in the &quot;reference guide&quot;
section.</p>
<h3><a class="header" href="#controlling-query-modes" id="controlling-query-modes">Controlling query modes</a></h3>
<p>Input queries, as described in the trait, are specified via the
<code>#[salsa::input]</code> attribute.</p>
<p>Derived queries can be customized by the following attributes,
attached to the getter method (e.g., <code>fn my_query(..)</code>):</p>
<ul>
<li><code>#[salsa::invoke(foo::bar)]</code> specifies the path to the function to invoke
when the query is called (default is <code>my_query</code>).</li>
<li><code>#[salsa::volatile]</code> specifies a &quot;volatile&quot; query, which is assumed to
read untracked input and hence must be re-executed on every revision.</li>
<li><code>#[salsa::dependencies]</code> specifies a &quot;dependencies-only&quot; query, which is assumed to
read untracked input and hence must be re-executed on every revision.</li>
</ul>
<h2><a class="header" href="#creating-the-database" id="creating-the-database">Creating the database</a></h2>
<p>Creating a salsa database works by using a <code>#[salsa::database(..)]</code>
attribute. The <code>..</code> content should be a list of paths leading to the
storage structs for each query group that the database will
implement. It is no longer necessary to list the individual
queries. In addition to the <code>salsa::database</code> query, the struct must
have access to a <code>salsa::Runtime</code> and implement the <code>salsa::Database</code>
trait. Hence the complete declaration looks roughly like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[salsa::database(MyGroupStorage)]
struct MyDatabase {
  runtime: salsa::Runtime&lt;MyDatabase&gt;,
}

impl salsa::Database for MyDatabase {
  fn salsa_runtime(&amp;self) -&gt; salsa::Runtime&lt;MyDatabase&gt; {
    &amp;self.runtime
  }
}  
<span class="boring">}
</span></code></pre></pre>
<p>This (procedural) macro generates various impls and types that cause
<code>MyDatabase</code> to implement all the traits for the query groups it
supports, and which customize the storage in the runtime to have all
the data needed. Users should not have to interact with these details,
and they are written out in the reference guide section.</p>
<h1><a class="header" href="#reference-guide-1" id="reference-guide-1">Reference guide</a></h1>
<p>The goal here is not to give the <em>full</em> details of how to do the
lowering, but to describe the key concepts. Throughout the text, we
will refer to names (e.g., <code>MyGroup</code> or <code>MyGroupStorage</code>) that appear
in the example from the User's Guide -- this indicates that we use
whatever name the user provided.</p>
<h2><a class="header" href="#the-plumbingquerygroup-trait" id="the-plumbingquerygroup-trait">The <code>plumbing::QueryGroup</code> trait</a></h2>
<p>The <code>QueryGroup</code> trait is a new trait added to the plumbing module. It
is implemented by the query group storage struct <code>MyGroupStorage</code>. Its
role is to link from that struct to the various bits of data that the
salsa runtime needs:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait QueryGroup&lt;DB: Database&gt; {
    type GroupStorage;
    type GroupKey;
}
<span class="boring">}
</span></code></pre></pre>
<p>This trait is implemented by the <strong>storage struct</strong> (<code>MyGroupStorage</code>)
in our example. You can see there is a bit of confusing nameing going
on here -- what we call (for user's) the &quot;storage struct&quot; actually
does not wind up containing the true <em>storage</em> (that is, the hasmaps
and things salsa uses). Instead, it merely implements the <code>QueryGroup</code>
trait, which has associated types that lead us to structs we need:</p>
<ul>
<li>the <strong>group storage</strong> contains the hashmaps and things for all the queries in the group</li>
<li>the <strong>group key</strong> is an enum with variants for each of the
queries. It basically stores all the data needed to identify some
particular <em>query value</em> from within the group -- that is, the name
of the query, plus the keys used to invoke it.</li>
</ul>
<p>As described further on, the <code>#[salsa::query_group]</code> macro is
responsible will generate an impl of this trait for the
<code>MyGroupStorage</code> struct, along with the group storage and group key
type definitions.</p>
<h2><a class="header" href="#the-plumbinghasquerygroupg-trait" id="the-plumbinghasquerygroupg-trait">The <code>plumbing::HasQueryGroup&lt;G&gt;</code> trait</a></h2>
<p>The <code>HasQueryGroup&lt;G&gt;</code> struct a new trait added to the plumbing
module. It is implemented by the database struct <code>MyDatabase</code> for
every query group that <code>MyDatabase</code> supports. Its role is to offer
methods that move back and forth between the context of the <em>full
database</em> to the context of an <em>individual query group</em>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait HasQueryGroup&lt;G&gt;: Database
where
    G: QueryGroup&lt;Self&gt;,
{
    /// Access the group storage struct from the database.
    fn group_storage(db: &amp;Self) -&gt; &amp;G::GroupStorage;

    /// &quot;Upcast&quot; a group key into a database key.
    fn database_key(group_key: G::GroupKey) -&gt; Self::DatabaseKey;
}
<span class="boring">}
</span></code></pre></pre>
<p>Here the &quot;database key&quot; is an enum that contains variants for each
group. Its role is to take group key and puts it into the context of
the entire database.</p>
<h2><a class="header" href="#the-query-trait" id="the-query-trait">The <code>Query</code> trait</a></h2>
<p>The query trait (pre-existing) is extended to include links to its
group, and methods to convert from the group storage to the query
storage, plus methods to convert from a query key up to the group key:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Query&lt;DB: Database&gt;: Debug + Default + Sized + 'static {
    /// Type that you you give as a parameter -- for queries with zero
    /// or more than one input, this will be a tuple.
    type Key: Clone + Debug + Hash + Eq;

    /// What value does the query return?
    type Value: Clone + Debug;

    /// Internal struct storing the values for the query.
    type Storage: plumbing::QueryStorageOps&lt;DB, Self&gt; + Send + Sync;

    /// Associate query group struct.
    type Group: plumbing::QueryGroup&lt;
        DB,
        GroupStorage = Self::GroupStorage,
        GroupKey = Self::GroupKey,
    &gt;;

    /// Generated struct that contains storage for all queries in a group.
    type GroupStorage;

    /// Type that identifies a particular query within the group + its key.
    type GroupKey;

    /// Extact storage for this query from the storage for its group.
    fn query_storage(group_storage: &amp;Self::GroupStorage) -&gt; &amp;Self::Storage;

    /// Create group key for this query.
    fn group_key(key: Self::Key) -&gt; Self::GroupKey;
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#converting-tofrom-the-context-of-the-full-database-generically" id="converting-tofrom-the-context-of-the-full-database-generically">Converting to/from the context of the full database generically</a></h2>
<p>Putting all the previous plumbing traits together, this means
that given:</p>
<ul>
<li>a database <code>DB</code> that implements <code>HasGroupStorage&lt;G&gt;</code>;</li>
<li>a group struct <code>G</code> that implements <code>QueryGroup&lt;DB&gt;</code>; and,</li>
<li>and a query struct <code>Q</code> that implements <code>Query&lt;DB, Group = G&gt;</code></li>
</ul>
<p>we can (generically) get the storage for the individual query
<code>Q</code> out from the database <code>db</code> via a two-step process:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let group_storage = HasGroupStorage::group_storage(db);
let query_storage = Query::query_storage(group_storage);
<span class="boring">}
</span></code></pre></pre>
<p>Similarly, we can convert from the key to an individual query
up to the &quot;database key&quot; in a two-step process:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let group_key = Query::group_key(key);
let db_key = HasGroupStorage::database_key(group_key);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#lowering-query-groups" id="lowering-query-groups">Lowering query groups</a></h2>
<p>The role of the <code>#[salsa::query_group(MyGroupStorage)] trait MyGroup { .. }</code> macro is primarily to generate the group storage struct and the
impl of <code>QueryGroup</code>.  That involves generating the following things:</p>
<ul>
<li>the query trait <code>MyGroup</code> itself, but with:
<ul>
<li><code>salsa::foo</code> attributes stripped</li>
<li><code>#[salsa::input]</code> methods expanded to include setters:
<ul>
<li><code>fn set_my_input(&amp;mut self, key: K1, value__: V1);</code></li>
<li><code>fn set_constant_my_input(&amp;mut self, key: K1, value__: V1);</code></li>
</ul>
</li>
</ul>
</li>
<li>the query group storage struct <code>MyGroupStorage</code>
<ul>
<li>We also generate an impl of <code>QueryGroup&lt;DB&gt;</code> for <code>MyGroupStorage</code>,
linking to the internal strorage struct and group key enum</li>
</ul>
</li>
<li>the individual query types
<ul>
<li>Ideally, we would use Rust hygiene to hide these struct, but as
that is not currently possible they are given names based on the
queries, but converted to camel-case (e.g., <code>MyInputQuery</code> and <code>MyQueryQuery</code>).</li>
<li>They implement the <code>salsa::Query</code> trait.</li>
</ul>
</li>
<li>the internal group storage struct
<ul>
<li>Ideally, we would use Rust hygiene to hide this struct, but as
that is not currently possible it is entitled
<code>MyGroupGroupStorage&lt;DB&gt;</code>. Note that it is generic with respect to
the database <code>DB</code>. This is because the actual query storage
requires sometimes storing database key's and hence we need to
know the final database type.</li>
<li>It contains one field per query with a link to the storage information
for that query:
<ul>
<li><code>my_query: &lt;MyQueryQuery as salsa::plumbing::Query&lt;DB&gt;&gt;::Storage</code></li>
<li>(the <code>MyQueryQuery</code> type is also generated, see the &quot;individual query types&quot; below)</li>
</ul>
</li>
<li>The internal group storage struct offers a public, inherent method
<code>for_each_query</code>:
<ul>
<li><code>fn for_each_query(db: &amp;DB, op: &amp;mut dyn FnMut(...)</code></li>
<li>this is invoked by the code geneated by <code>#[salsa::database]</code> when implementing the
<code>for_each_query</code> method of the <code>plumbing::DatabaseOps</code> trait</li>
</ul>
</li>
</ul>
</li>
<li>the group key
<ul>
<li>Again, ideally we would use hygiene to hide the name of this struct,
but since we cannot, it is entitled <code>MyGroupGroupKey</code></li>
<li>It is an enum which contains one variant per query with the value being the key:
<ul>
<li><code>my_query(&lt;MyQueryQuery as salsa::plumbing::Query&lt;DB&gt;&gt;::Key)</code></li>
</ul>
</li>
<li>The group key enum offers a public, inherent method <code>maybe_changed_since</code>:
<ul>
<li><code>fn maybe_changed_since&lt;DB&gt;(db: &amp;DB, db_descriptor: &amp;DB::DatabaseKey, revision: Revision)</code></li>
<li>it is invoked when implementing <code>maybe_changed_since</code> for the database key</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#lowering-database-storage" id="lowering-database-storage">Lowering database storage</a></h2>
<p>The <code>#[salsa::database(MyGroup)]</code> attribute macro creates the links to the query groups.
It generates the following things:</p>
<ul>
<li>impl of <code>HasQueryGroup&lt;MyGroup&gt;</code> for <code>MyDatabase</code>
<ul>
<li>Naturally, there is one such impl for each query group.</li>
</ul>
</li>
<li>the database key enum
<ul>
<li>Ideally, we would use Rust hygiene to hide this enum, but currently
it is called <code>__SalsaDatabaseKey</code>.</li>
<li>The database key is an enum with one variant per query group:
<ul>
<li><code>MyGroupStorage(&lt;MyGroupStorage as QueryGroup&lt;MyDatabase&gt;&gt;::GroupKey)</code></li>
</ul>
</li>
</ul>
</li>
<li>the database storage struct
<ul>
<li>Ideally, we would use Rust hygiene to hide this enum, but currently
it is called <code>__SalsaDatabaseStorage</code>.</li>
<li>The database storage struct contains one field per query group, storing
its internal storage:
<ul>
<li><code>my_group_storage: &lt;MyGroupStorage as QueryGroup&lt;MyDatabase&gt;&gt;::GroupStorage</code></li>
</ul>
</li>
</ul>
</li>
<li>impl of <code>plumbing::DatabaseStorageTypes</code> for <code>MyDatabase</code>
<ul>
<li>This is a plumbing trait that links to the database storage / database key types.</li>
<li>The <code>salsa::Runtime</code> uses it to determine what data to include. The query types
use it to determine a database-key.</li>
</ul>
</li>
<li>impl of <code>plumbing::DatabaseOps</code> for <code>MyDatabase</code>
<ul>
<li>This contains a <code>for_each_query</code> method, which is implemented by invoking, in turn,
the inherent methods defined on each query group storage struct.</li>
</ul>
</li>
<li>impl of <code>plumbing::DatabaseKey</code> for the database key enum
<ul>
<li>This contains a method <code>maybe_changed_since</code>. We implement this by
matching to get a particular group key, and then invoking the
inherent method on the group key struct.</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#alternatives" id="alternatives">Alternatives</a></h1>
<p>This proposal results from a fair amount of iteration. Compared to the
status quo, there is one primary downside. We also explain a few things here that
may not be obvious.</p>
<h2><a class="header" href="#why-include-a-group-storage-struct" id="why-include-a-group-storage-struct">Why include a group storage struct?</a></h2>
<p>You might wonder why we need the <code>MyGroupStorage</code> struct at all. It is a touch of boilerplate,
but there are several advantages to it:</p>
<ul>
<li>You can't attach associated types to the trait itself. This is because the &quot;type version&quot;
of the trait (<code>dyn MyGroup</code>) may not be available, since not all traits are dyn-capable.</li>
<li>We try to keep to the principle that &quot;any type that might be named
externally from the macro is given its name by the user&quot;. In this
case, the <code>[salsa::database]</code> attribute needed to name group storage
structs.
<ul>
<li>In earlier versions, we tried to auto-generate these names, but
this failed because sometimes users would want to <code>pub use</code> the
query traits and hide their original paths.</li>
<li>(One exception to this principle today are the per-query structs.)</li>
</ul>
</li>
<li>We expect that we can use the <code>MyGroupStorage</code> to achieve more
encapsulation in the future. While the struct must be public and
named from the database, the <em>trait</em> (and query key/value types)
actually does not have to be.</li>
</ul>
<h2><a class="header" href="#downside-size-of-a-database-key" id="downside-size-of-a-database-key">Downside: Size of a database key</a></h2>
<p>Database keys now wind up with two discriminants: one to identify the
group, and one to identify the query. That's a bit sad. This could be
overcome by using unsafe code: the idea would be that a group/database
key would be stored as the pair of an integer and a <code>union</code>. Each
group within a given database would be assigned a range of integer
values, and the unions would store the actual key values. We leave
such a change for future work.</p>
<h1><a class="header" href="#future-possibilities" id="future-possibilities">Future possibilities</a></h1>
<p>Here are some ideas we might want to do later.</p>
<h2><a class="header" href="#no-generics" id="no-generics">No generics</a></h2>
<p>We leave generic parameters on the query group trait etc for future work.</p>
<h2><a class="header" href="#public--private" id="public--private">Public / private</a></h2>
<p>We'd like the ability to make more details from the query groups
private. This will require some tinkering.</p>
<h2><a class="header" href="#inline-query-definitions" id="inline-query-definitions">Inline query definitions</a></h2>
<p>Instead of defining queries in separate functions, it might be nice to
have the option of defining query methods in the trait itself:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[salsa::query_group(MyGroupStorage)]
trait MyGroup {
  #[salsa::input]
  fn my_input(&amp;self, key: K1) -&gt; V1;
  
  fn my_query(&amp;self, key: K2) -&gt; V2 {
      // define my-query right here!
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>It's a bit tricky to figure out how to handle this, so that is left
for future work. Also, it would mean that the method body itself is
inside of a macro (the procedural macro) which can make IDE
integration harder.</p>
<h2><a class="header" href="#non-query-functions" id="non-query-functions">Non-query functions</a></h2>
<p>It might be nice to be able to include functions in the trait that are
<em>not</em> queries, but rather helpers that compose queries. This should be
pretty easy, just need a suitable <code>#[salsa]</code> attribute.</p>
<h1><a class="header" href="#summary-1" id="summary-1">Summary</a></h1>
<ul>
<li>We introduce <code>#[salsa::interned]</code> queries which convert a <code>Key</code> type
into a numeric index of type <code>Value</code>, where <code>Value</code> is either the
type <code>InternId</code> (defined by a salsa) or some newtype thereof.</li>
<li>Each interned query <code>foo</code> also produces an inverse <code>lookup_foo</code>
method that converts back from the <code>Value</code> to the <code>Key</code> that was
interned.</li>
<li>The <code>InternId</code> type (defined by salsa) is basically a newtype'd integer,
but it internally uses <code>NonZeroU32</code> to enable space-saving optimizations
in memory layout.</li>
<li>The <code>Value</code> types can be any type that implements the
<code>salsa::InternIndex</code> trait, also introduced by this RFC. This trait
has two methods, <code>from_intern_id</code> and <code>as_intern_id</code>.</li>
<li>The interning is integrated into the GC and tracked like any other
query, which means that interned values can be garbage-collected,
and any computation that was dependent on them will be collected.</li>
</ul>
<h1><a class="header" href="#motivation-2" id="motivation-2">Motivation</a></h1>
<h2><a class="header" href="#the-need-for-interning" id="the-need-for-interning">The need for interning</a></h2>
<p>Many salsa applications wind up needing the ability to construct
&quot;interned keys&quot;. Frequently this pattern emerges because we wish to
construct identifiers for things in the input. These identifiers
generally have a &quot;tree-like shape&quot;. For example, in a compiler, there
may be some set of input files -- these are enumerated in the inputs
and serve as the &quot;base&quot; for a path that leads to items in the user's
input. But within an input file, there are additional structures, such
as <code>struct</code> or <code>impl</code> declarations, and these structures may contain
further structures within them (such as fields or methods). This gives
rise to a path like so that can be used to identify a given item:</p>
<pre><code>PathData = &lt;file-name&gt;
         | PathData / &lt;identifier&gt;
</code></pre>
<p>These paths <em>could</em> be represented in the compiler with an <code>Arc</code>, but
because they are omnipresent, it is convenient to intern them instead
and use an integer. Integers are <code>Copy</code> types, which is convenient,
and they are also small (32 bits typically suffices in practice).</p>
<h2><a class="header" href="#why-interning-is-difficult-today-garbage-collection" id="why-interning-is-difficult-today-garbage-collection">Why interning is difficult today: garbage collection</a></h2>
<p>Unfortunately, integrating interning into salsa at present presents
some hard choices, particularly with a long-lived application. You can
easily add an interning table into the database, but unless you do
something clever, <strong>it will simply grow and grow forever</strong>. But as the
user edits their programs, some paths that used to exist will no
longer be relevant -- for example, a given file or impl may be
removed, invalidating all those paths that were based on it. </p>
<p>Due to the nature of salsa's recomputation model, it is not easy to
detect when paths that used to exist in a prior revision are no longer
relevant in the next revision. <strong>This is because salsa never
explicitly computes &quot;diffs&quot; of this kind between revisions -- it just
finds subcomputations that might have gone differently and re-executes
them.</strong> Therefore, if the code that created the paths (e.g., that
processed the result of the parser) is part of a salsa query, it will
simply not re-create the invalidated paths -- there is no explicit
&quot;deletion&quot; point.</p>
<p>In fact, the same is true of all of salsa's memoized query values. We
may find that in a new revision, some memoized query values are no
longer relevant. For example, in revision R1, perhaps we computed
<code>foo(22)</code> and <code>foo(44)</code>, but in the new input, we now only need to
compute <code>foo(22)</code>. The <code>foo(44)</code> value is still memoized, we just
never asked for its value. <strong>This is why salsa includes a garbage
collector, which can be used to cleanup these memoized values that are
no longer relevant.</strong></p>
<p>But using a garbage collection strategy with a hand-rolled interning
scheme is not easy. You <em>could</em> trace through all the values in
salsa's memoization tables to implement a kind of mark-and-sweep
scheme, but that would require for salsa to add such a mechanism. It
might also be quite a lot of tracing! The current salsa GC mechanism has no
need to walk through the values themselves in a memoization table, it only
examines the keys and the metadata (unless we are freeing a value, of course).</p>
<h2><a class="header" href="#how-this-rfc-changes-the-situation" id="how-this-rfc-changes-the-situation">How this RFC changes the situation</a></h2>
<p>This RFC presents an alternative. The idea is to move the interning
into salsa itself by creating special &quot;interning
queries&quot;. Dependencies on these queries are tracked like any other
query and hence they integrate naturally with salsa's garbage
collection mechanisms.</p>
<h1><a class="header" href="#users-guide-2" id="users-guide-2">User's guide</a></h1>
<p>This section covers how interned queries are expected to be used.</p>
<h2><a class="header" href="#declaring-an-interned-query" id="declaring-an-interned-query">Declaring an interned query</a></h2>
<p>You can declare an interned query like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[salsa::query_group]
trait Foo {
  #[salsa::interned]
  fn intern_path_data(&amp;self, data: PathData) -&gt; salsa::InternId;
]
<span class="boring">}
</span></code></pre></pre>
<p><strong>Query keys.</strong> Like any query, these queries can take any number of keys. If multiple
keys are provided, then the interned key is a tuple of each key
value. In order to be interned, the keys must implement <code>Clone</code>,
<code>Hash</code> and <code>Eq</code>. </p>
<p><strong>Return type.</strong> The return type of an interned key may be of any type
that implements <code>salsa::InternIndex</code>: salsa provides an impl for the
type <code>salsa::InternId</code>, but you can implement it for your own.</p>
<p><strong>Inverse query.</strong> For each interning query, we automatically generate
a reverse query that will invert the interning step. It is named
<code>lookup_XXX</code>, where <code>XXX</code> is the name of the query. Hence here it
would be <code>fn lookup_intern_path(&amp;self, key: salsa::InternId) -&gt; Path</code>.</p>
<h2><a class="header" href="#the-expected-us" id="the-expected-us">The expected us</a></h2>
<p>Using an interned query is quite straightforward. You simply invoke it
with a key, and you will get back an integer, and you can use the
generated <code>lookup</code> method to convert back to the original value:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let key = db.intern_path(path_data1);
let path_data2 = db.lookup_intern_path_data(key);
<span class="boring">}
</span></code></pre></pre>
<p>Note that the interned value will be cloned -- so, like all Salsa
values, it is best if that is a cheap operation. Interestingly,
interning can help to keep recursive, tree-shapes values cheap,
because the &quot;pointers&quot; within can be replaced with interned keys.</p>
<h2><a class="header" href="#custom-return-types" id="custom-return-types">Custom return types</a></h2>
<p>The return type for an intern query does not have to be a <code>InternId</code>. It can
be any type that implements the <code>salsa::InternKey</code> trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait InternKey {
    /// Create an instance of the intern-key from a `InternId` value.
    fn from_intern_id(v: InternId) -&gt; Self;

    /// Extract the `InternId` with which the intern-key was created.
    fn as_intern_id(&amp;self) -&gt; InternId;
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#recommended-practice" id="recommended-practice">Recommended practice</a></h2>
<p>This section shows the recommended practice for using interned keys,
building on the <code>Path</code> and <code>PathData</code> example that we've been working
with. </p>
<h3><a class="header" href="#naming-convention" id="naming-convention">Naming Convention</a></h3>
<p>First, note the recommended naming convention: the <em>intern key</em> is
<code>Foo</code> and the key's associated data <code>FooData</code> (in our case, <code>Path</code> and
<code>PathData</code>). The intern key is given the shorter name because it is
used far more often. Moreover, other types should never store the full
data, but rather should store the interned key.</p>
<h3><a class="header" href="#defining-the-intern-key" id="defining-the-intern-key">Defining the intern key</a></h3>
<p>The intern key should always be a newtype struct that implements
the <code>InternKey</code> trait. So, something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Path(InternId);

impl salsa::InternKey for Path {
    fn from_intern_id(v: InternId) -&gt; Self {
        Path(v)
    }

    fn as_intern_id(&amp;self) -&gt; InternId {
        self.0
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#convenient-lookup-method" id="convenient-lookup-method">Convenient lookup method</a></h3>
<p>It is often convenient to add a <code>lookup</code> method to the newtype key:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Path {
    // Adding this method is often convenient, since you can then
    // write `path.lookup(db)` to access the data, which reads a bit better.
    pub fn lookup(&amp;self, db: &amp;impl MyDatabase) -&gt; PathData {
        db.lookup_intern_path_data(*self)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#defining-the-data-type" id="defining-the-data-type">Defining the data type</a></h3>
<p>Recall that our paths were defined by a recursive grammar like so:</p>
<pre><code>PathData = &lt;file-name&gt;
         | PathData / &lt;identifier&gt;
</code></pre>
<p>This recursion is quite typical of salsa applications. The recommended
way to encode it in the <code>PathData</code> structure itself is to build on other
intern keys, like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Hash, Eq, ..)]
enum PathData {
  Root(String),
  Child(Path, String),
  //    ^^^^ Note that the recursive reference here
  //         is encoded as a Path.
}
<span class="boring">}
</span></code></pre></pre>
<p>Note though that the <code>PathData</code> type will be cloned whenever the value
for an interned key is looked up, and it may also be cloned to store
dependency information between queries. So, as an optimization, you
might prefer to avoid <code>String</code> in favor of <code>Arc&lt;String&gt;</code> -- or even
intern the strings as well.</p>
<h2><a class="header" href="#interaction-with-the-garbage-collector" id="interaction-with-the-garbage-collector">Interaction with the garbage collector</a></h2>
<p>Interned keys can be garbage collected as normal, with one
caveat. Even if requested, Salsa will never collect the results
generated in the current revision. This is because it would permit the
same key to be interned twice in the same revision, possibly mapping
to distinct intern keys each time.</p>
<p>Note that if an interned key <em>is</em> collected, its index will be
re-used.  Salsa's dependency tracking system should ensure that
anything incorporating the older value is considered dirty, but you
may see the same index showing up more than once in the logs.</p>
<h1><a class="header" href="#reference-guide-2" id="reference-guide-2">Reference guide</a></h1>
<p>Interned keys are implemented using a hash-map that maps from the
interned data to its index, as well as a vector containing (for each
index) various bits of data. In addition to the interned data, we must
track the revision in which the value was interned and the revision in
which it was last accessed, to help manage the interaction with the
GC. Finally, we have to track some sort of free list that tracks the
keys that are being re-used. The current implementation never actually
shrinks the vectors and maps from their maximum size, but this might
be a useful thing to be able to do (this is effectively a memory
allocator, so standard allocation strategies could be used here).</p>
<h2><a class="header" href="#internid" id="internid">InternId</a></h2>
<p>Presently the <code>InternId</code> type is implemented to wrap a <code>NonZeroU32</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct InternId {
    value: NonZeroU32,
}
<span class="boring">}
</span></code></pre></pre>
<p>This means that <code>Option&lt;InternId&gt;</code> (or <code>Option&lt;Path&gt;</code>, continuing our
example from before) will only be a single word. To accommodate this,
the <code>InternId</code> constructors require that the value is less than
<code>InternId::MAX</code>; the value is deliberately set low (currently to
<code>0xFFFF_FF00</code>) to allow for more sentinel values in the future (Rust
doesn't presently expose the capability of having sentinel values
other than zero on stable, but it is possible on nightly).</p>
<h1><a class="header" href="#alternatives-and-future-work-1" id="alternatives-and-future-work-1">Alternatives and future work</a></h1>
<p>None at present.</p>
<h1><a class="header" href="#summary-2" id="summary-2">Summary</a></h1>
<p>Allow to specify a dependency on a query group without making it a super trait.</p>
<h1><a class="header" href="#motivation-3" id="motivation-3">Motivation</a></h1>
<p>Currently, there's only one way to express that queries from group <code>A</code> can use
another group <code>B</code>: namely, <code>B</code> can be a super-trait of <code>A</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[salsa::query_group(AStorage)]
trait A: B {

}
<span class="boring">}
</span></code></pre></pre>
<p>This approach works and allows one to express complex dependencies. However,
this approach falls down when one wants to make a dependency a private
implementation detail: Clients with <code>db: &amp;impl A</code> can freely call <code>B</code> methods on
the <code>db</code>.</p>
<p>This is a bad situation from software engineering point of view: if everything
is accessible, it's hard to make distinction between public API and private
implementation details. In the context of salsa the situation is even worse,
because it breaks &quot;firewall&quot; pattern. It's customary to wrap low-level
frequently-changing or volatile queries into higher-level queries which produce
stable results and contain invalidation. In the current salsa, however, it's
very easy to accidentally call a low-level volatile query instead of a wrapper,
introducing and undesired dependency.</p>
<h1><a class="header" href="#users-guide-3" id="users-guide-3">User's guide</a></h1>
<p>To specify query dependencies, a <code>requires</code> attribute should be used:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[salsa::query_group(SymbolsDatabaseStorage)]
#[salsa::requires(SyntaxDatabase)]
#[salsa::requires(EnvDatabase)]
pub trait SymbolsDatabase {
    fn get_symbol_by_name(&amp;self, name: String) -&gt; Symbol;
}
<span class="boring">}
</span></code></pre></pre>
<p>The argument of <code>requires</code> is a path to a trait. The traits from all <code>requires</code>
attributes are available when implementing the query:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_symbol_by_name(
    db: &amp;(impl SymbolsDatabase + SyntaxDatabase + EnvDatabase),
    name: String,
) -&gt; Symbol {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>However, these traits are <strong>not</strong> available without explicit bounds:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fuzzy_find_symbol(db: &amp;impl SymbolsDatabase, name: String) {
    // Can't accidentally call methods of the `SyntaxDatabase`
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that, while the RFC does not propose to add per-query dependencies, query
implementation can voluntarily specify only a subset of traits from <code>requires</code>
attribute:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_symbol_by_name(
    // Purposefully don't depend on EnvDatabase
    db: &amp;(impl SymbolsDatabase + SyntaxDatabase),
    name: String,
) -&gt; Symbol {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#reference-guide-3" id="reference-guide-3">Reference guide</a></h1>
<p>The implementation is straightforward and consists of adding traits from
<code>requires</code> attributes to various <code>where</code> bounds. For example, we would generate
the following blanket for above example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; SymbolsDatabase for T
where
    T: SyntaxDatabase + EnvDatabase,
    T: salsa::plumbing::HasQueryGroup&lt;SymbolsDatabaseStorage&gt;
{
    ...
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#alternatives-and-future-work-2" id="alternatives-and-future-work-2">Alternatives and future work</a></h1>
<p>The semantics of <code>requires</code> closely resembles <code>where</code>, so we could imagine a
syntax based on magical where clauses:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[salsa::query_group(SymbolsDatabaseStorage)]
pub trait SymbolsDatabase
    where ???: SyntaxDatabase + EnvDatabase
{
    fn get_symbol_by_name(&amp;self, name: String) -&gt; Symbol;
}
<span class="boring">}
</span></code></pre></pre>
<p>However, it's not obvious what should stand for <code>???</code>. <code>Self</code> won't be ideal,
because supertraits are a sugar for bounds on <code>Self</code>, and we deliberately want
different semantics. Perhaps picking a magical identifier like <code>DB</code> would work
though?</p>
<p>One potential future development here is per-query-function bounds, but they can
already be simulated by voluntarily requiring less bounds in the implementation
function.</p>
<p>Another direction for future work is privacy: because traits from <code>requires</code>
clause are not a part of public interface, in theory it should be possible to
restrict their visibility. In practice, this still hits public-in-private lint,
at least with a trivial implementation.</p>
<h1><a class="header" href="#summary-3" id="summary-3">Summary</a></h1>
<p>Add Least Recently Used values eviction as a supplement to garbage collection.</p>
<h1><a class="header" href="#motivation-4" id="motivation-4">Motivation</a></h1>
<p>Currently, the single mechanism for controlling memory usage in salsa is garbage
collection. Experience with rust-analyzer shown that it is insufficient for two
reasons:</p>
<ul>
<li>
<p>It's hard to determine which values should be collected. Current
implementation in rust-analyzer just periodically clears all values of
specific queries.</p>
</li>
<li>
<p>GC is in generally run in-between revision. However, especially after just
opening the project, the number of values <em>within a single revision</em> can be
high. In other words, GC doesn't really help with keeping peak memory usage
under control. While it is possible to run GC concurrently with calculations
(and this is in fact what rust-analyzer is doing right now to try to keep high
water mark of memory lower), this is highly unreliable an inefficient.</p>
</li>
</ul>
<p>The mechanism of LRU targets both of these weaknesses:</p>
<ul>
<li>
<p>LRU tracks which values are accessed, and uses this information to determine
which values are actually unused.</p>
</li>
<li>
<p>LRU has a fixed cap on the maximal number of entries, thus bounding the memory
usage.</p>
</li>
</ul>
<h1><a class="header" href="#users-guide-4" id="users-guide-4">User's guide</a></h1>
<p>It is possible to call <code>set_lru_capacity(n)</code> method on any non-input query. The
effect of this is that the table for the query stores at most <code>n</code> <em>values</em> in
the database. If a new value is computed, and there are already <code>n</code> existing
ones in the database, the least recently used one is evicted. Note that
information about query dependencies is <strong>not</strong> evicted. It is possible to
change lru capacity at runtime at any time. <code>n == 0</code> is a special case, which
completely disables LRU logic. LRU is not enabled by default.</p>
<h1><a class="header" href="#reference-guide-4" id="reference-guide-4">Reference guide</a></h1>
<p>Implementation wise, we store a linked hash map of keys, in the recently-used
order. Because reads of the queries are considered uses, we now need to
write-lock the query map even if the query is fresh. However we don't do this
bookkeeping if LRU is disabled, so you don't have to pay for it unless you use
it.</p>
<p>A slight complication arises with volatile queries (and, in general, with any
query with an untracked input). Similarly to GC, evicting such a query could
lead to an inconsistent database. For this reason, volatile queries are never
evicted.</p>
<h1><a class="header" href="#alternatives-and-future-work-3" id="alternatives-and-future-work-3">Alternatives and future work</a></h1>
<p>LRU is a compromise, as it is prone to both accidentally evicting useful queries
and needlessly holding onto useless ones. In particular, in the steady state and
without additional GC, memory usage will be proportional to the lru capacity: it
is not only an upper bound, but a lower bound as well!</p>
<p>In theory, some deterministic way of evicting values when you for sure don't
need them anymore maybe more efficient. However, it is unclear how exactly that
would work! Experiments in rust-analyzer show that it's not easy to tame a
dynamic crate graph, and that simplistic phase-based strategies fall down.</p>
<p>It's also worth noting that, unlike GC, LRU can in theory be <em>more</em> memory
efficient than deterministic memory management. Unlike a traditional GC, we can
safely evict &quot;live&quot; objects and recalculate them later. That makes possible to
use LRU for problems whose working set of &quot;live&quot; queries is larger than the
available memory, at the cost of guaranteed recomputations.</p>
<p>Currently, eviction is strictly LRU base. It should be possible to be smarter
and to take size of values and time that is required to recompute them into
account when making decisions about eviction.</p>
<h1><a class="header" href="#summary-4" id="summary-4">Summary</a></h1>
<ul>
<li>Introduce a user-visibile concept of <code>Durability</code></li>
<li>Adjusting the &quot;durability&quot; of an input can allow salsa to skip a lot of validation work</li>
<li>Garbage collection -- particularly of interned values -- however becomes more complex</li>
<li>Possible future expansion: automatic detection of more &quot;durable&quot; input values</li>
</ul>
<h1><a class="header" href="#motivation-5" id="motivation-5">Motivation</a></h1>
<h2><a class="header" href="#making-validation-faster-by-optimizing-for-durability" id="making-validation-faster-by-optimizing-for-durability">Making validation faster by optimizing for &quot;durability&quot;</a></h2>
<p>Presently, salsa's validation logic requires traversing all
dependencies to check that they have not changed. This can sometimes
be quite costly in practice: rust-analyzer for example sometimes
spends as much as 90ms revalidating the results from a no-op
change. One option to improve this is simply optimization --
<a href="https://github.com/salsa-rs/salsa/pull/176">salsa#176</a> for example reduces validation times significantly, and
there remains opportunity to do better still. However, even if we are
able to traverse the dependency graph more efficiently, it will still
be an O(n) process. It would be nice if we could do better.</p>
<p>One observation is that, in practice, there are often input values
that are known to change quite infrequently. For example, in
rust-analyzer, the standard library and crates downloaded from
crates.io are unlikely to change (though changes are possible; see
below). Similarly, the <code>Cargo.toml</code> file for a project changes
relatively infrequently compared to the sources. We say then that
these inputs are more <strong>durable</strong> -- that is, they change less frequently.</p>
<p>This RFC proposes a mechanism to take advantage of durability for
optimization purposes. Imagine that we have some query Q that depends
solely on the standard library. The idea is that we can track the last
revision R when the standard library was changed. Then, when
traversing dependencies, we can skip traversing the dependencies of Q
if it was last validated after the revision R. Put another way, we
only need to traverse the dependencies of Q when the standard library
changes -- which is unusual. If the standard library <em>does</em> change,
for example by user's tinkering with the internal sources, then yes we
walk the dependencies of Q to see if it is affected.</p>
<h1><a class="header" href="#users-guide-5" id="users-guide-5">User's guide</a></h1>
<h2><a class="header" href="#the-durability-type" id="the-durability-type">The durability type</a></h2>
<p>We add a new type <code>salsa::Durability</code> which has there associated constants:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone, Debug, Ord)]
pub struct Durability(..);

impl Durability {
  // Values that change regularly, like the source to the current crate.
  pub const LOW: Durability;
  
  // Values that change infrequently, like Cargo.toml.
  pub const MEDIUM: Durability;

  // Values that are not expected to change, like sources from crates.io or the stdlib.
  pub const HIGH: Durability;
}
<span class="boring">}
</span></code></pre></pre>
<p>h## Specifying the durability of an input</p>
<p>When setting an input <code>foo</code>, one can now invoke a method
<code>set_foo_with_durability</code>, which takes a <code>Durability</code> as the final
argument:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// db.set_foo(key, value) is equivalent to:
db.set_foo_with_durability(key, value, Durability::LOW);

// This would indicate that `foo` is not expected to change: 
db.set_foo_with_durability(key, value, Durability::HIGH);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#durability-of-interned-values" id="durability-of-interned-values">Durability of interned values</a></h2>
<p>Interned values are always considered <code>Durability::HIGH</code>. This makes
sense as many queries that only use high durability inputs will also
make use of interning internally. A consequence of this is that they
will not be garbage collected unless you use the specific patterns
recommended below.</p>
<h2><a class="header" href="#synthetic-writes" id="synthetic-writes">Synthetic writes</a></h2>
<p>Finally, we add one new method, <code>synthetic_write(durability)</code>, 
available on the salsa runtime:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>db.salsa_runtime().synthetic_write(Durability::HIGH)
<span class="boring">}
</span></code></pre></pre>
<p>As the name suggests, <code>synthetic_write</code> causes salsa to act <em>as
though</em> a write to an input of the given durability had taken
place. This can be used for benchmarking, but it's also important to
controlling what values get garbaged collected, as described below.</p>
<h2><a class="header" href="#tracing-and-garbage-collection" id="tracing-and-garbage-collection">Tracing and garbage collection</a></h2>
<p>Durability affects garbage collection. The <code>SweepStrategy</code> struct is
modified as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Sweeps values which may be outdated, but which have not
/// been verified since the start of the current collection.
/// These are typically memoized values from previous computations
/// that are no longer relevant.
pub fn sweep_outdated(self) -&gt; SweepStrategy;

/// Sweeps values which have not been verified since the start 
/// of the current collection, even if they are known to be 
/// up to date. This can be used to collect &quot;high durability&quot; values
/// that are not *directly* used by the main query.
///
/// So, for example, imagine a main query `result` which relies
/// on another query `threshold` and (indirectly) on a `threshold_inner`:
///
/// ```
/// result(10) [durability: Low]
///    |
///    v
/// threshold(10) [durability: High]
///    |
///    v
/// threshold_inner(10)  [durability: High]
/// ```
///
/// If you modify a low durability input and then access `result`,
/// then `result(10)` and its *immediate* dependencies will 
/// be considered &quot;verified&quot;. However, because `threshold(10)` 
/// has high durability and no high durability input was modified,
/// we will not verify *its* dependencies, so `threshold_inner` is not 
/// verified (but it is also not outdated).
///
/// Collecting unverified things would therefore collect `threshold_inner(10)`.
/// Collecting only *outdated* things (i.e., with `sweep_outdated`)
/// would collect nothing -- but this does mean that some high durability
/// queries that are no longer relevant to your main query may stick around.
/// 
/// To get the most precise garbage collection, do a synthetic write with
/// high durability -- this will force us to verify *all* values. You can then
/// sweep unverified values.
pub fn sweep_unverified(self) -&gt; SweepStrategy;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#reference-guide-5" id="reference-guide-5">Reference guide</a></h1>
<h2><a class="header" href="#review-the-need-for-gc-to-collect-outdated-values" id="review-the-need-for-gc-to-collect-outdated-values">Review: The need for GC to collect outdated values</a></h2>
<p>In general, salsa's lazy validation scheme can lead to the accumulation
of garbage that is no longer needed. Consider a query like this one:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn derived1(db: &amp;impl Database, start: usize) {
  let middle = self.input(start);
  self.derived2(middle)
}
<span class="boring">}
</span></code></pre></pre>
<p>Now imagine that, on some particular run, we compute <code>derived1(22)</code>:</p>
<ul>
<li><code>derived1(22)</code>
<ul>
<li>executes <code>input(22)</code>, which returns <code>44</code></li>
<li>then executes <code>derived2(44)</code></li>
</ul>
</li>
</ul>
<p>The end result of this execution will be a dependency graph
like:</p>
<pre><code>derived1(22) -&gt; derived2(44)
  |
  v
input(22)
</code></pre>
<p>Now. imagine that the user modifies <code>input(22)</code> to have the value <code>45</code>.
The next time <code>derived1(22)</code> executes, it will load <code>input(22)</code> as before,
but then execute <code>derived2(45)</code>. This leaves us with a dependency
graph as follows:</p>
<pre><code>derived1(22) -&gt; derived2(45)
  |
  v
input(22)       derived2(44)
</code></pre>
<p>Notice that we still see <code>derived2(44)</code> in the graph. This is because
we memoized the result in last round and then simply had no use for it
in this round. The role of GC is to collect &quot;outdated&quot; values like
this one.</p>
<p>###Review: Tracing and GC before durability</p>
<p>In the absence of durability, when you execute a query Q in some new
revision where Q has not previously executed, salsa must trace back
through all the queries that Q depends on to ensure that they are
still up to date. As each of Q's dependencies is validated, we mark it
to indicate that it has been checked in the current revision (and
thus, within a particular revision, we would never validate or trace a
particular query twice).</p>
<p>So, to continue our example, when we first executed <code>derived1(22)</code>
in revision R1, we might have had a graph like:</p>
<pre><code>derived1(22)   -&gt; derived2(44)
[verified: R1]    [verified: R1]
  |
  v
input(22)
</code></pre>
<p>Now, after we modify <code>input(22)</code> and execute <code>derived1(22)</code> again, we 
would have a graph like:</p>
<pre><code>derived1(22)   -&gt; derived2(45)
[verified: R2]    [verified: R2]
  |
  v
input(22)         derived2(44)
                  [verified: R1]
</code></pre>
<p>Note that <code>derived2(44)</code>, the outdated value, never had its &quot;verified&quot;
revision updated, because we never accessed it.</p>
<p>Salsa leverages this validation stamp to serve as the &quot;marking&quot; phase
of a simple mark-sweep garbage collector. The idea is that the sweep
method can collect any values that are &quot;outdated&quot; (whose &quot;verified&quot;
revision is less than the current revision).</p>
<p>The intended model is that one can do a &quot;mark-sweep&quot; style garbage
collection like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Modify some input, triggering a new revision.
db.set_input(22, 45);

// The **mark** phase: execute the &quot;main query&quot;, with the intention
// that we wish to retain all the memoized values needed to compute
// this main query, but discard anything else. For example, in an IDE
// context, this might be a &quot;compute all errors&quot; query.
db.derived1(22);

// The **sweep** phase: discard anything that was not traced during
// the mark phase.
db.sweep_all(...);
<span class="boring">}
</span></code></pre></pre>
<p>In the case of our example, when we execute <code>sweep_all</code>, it would
collect <code>derived2(44)</code>.</p>
<h2><a class="header" href="#challenge-durability-lets-us-avoid-tracing" id="challenge-durability-lets-us-avoid-tracing">Challenge: Durability lets us avoid tracing</a></h2>
<p>This tracing model is affected by the move to durability. Now, if some
derived value has a high durability, we may skip tracing its
descendants altogether. This means that they would never be &quot;verified&quot;
-- that is, their &quot;verified date&quot; would never be updated.</p>
<p>This is why we modify the definition of &quot;outdated&quot; as follows:</p>
<ul>
<li>For a query value <code>Q</code> with durability <code>D</code>, let <code>R_lc</code> be the revision when
values of durability <code>D</code> last changed. Let <code>R_v</code> be the revision when
<code>Q</code> was last verified.</li>
<li><code>Q</code> is outdated if <code>R_v &lt; R_lc</code>.
<ul>
<li>In other words, if <code>Q</code> may have changed since it was last verified.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#collecting-interned-and-untracked-values" id="collecting-interned-and-untracked-values">Collecting interned and untracked values</a></h2>
<p>Most values can be collected whenever we like without influencing
correctness.  However, interned values and those with untracked
dependencies are an exception -- <strong>they can only be collected when
outdated</strong>.  This is because their values may not be reproducible --
in other words, re-executing an interning query (or one with untracked
dependencies, which can read arbitrary program state) twice in a row
may produce a different value. In the case of an interning query, for
example, we may wind up using a different integer than we did before.
If the query is outdated, this is not a problem: anything that
dependend on its result must also be outdated, and hence would be
re-executed and would observe the new value. But if the query is <em>not</em>
outdated, then we could get inconsistent result.s</p>
<h1><a class="header" href="#alternatives-and-future-work-4" id="alternatives-and-future-work-4">Alternatives and future work</a></h1>
<h2><a class="header" href="#rejected-arbitrary-durabilities" id="rejected-arbitrary-durabilities">Rejected: Arbitrary durabilities</a></h2>
<p>We considered permitting arbitrary &quot;levels&quot; of durability -- for
example, allowing the user to specify a number -- rather than offering
just three. Ultimately it seemed like that level of control wasn't
really necessary and that having just three levels would be sufficient
and simpler.</p>
<h2><a class="header" href="#rejected-durability-lattices" id="rejected-durability-lattices">Rejected: Durability lattices</a></h2>
<p>We also considered permitting a &quot;lattice&quot; of durabilities -- e.g., to
mirror the crate DAG in rust-analyzer -- but this is tricky because
the lattice itself would be dependent on other inputs.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="mermaid.min.js"></script>
        
        <script type="text/javascript" src="mermaid-init.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
