<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Salsa</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="mermaid.css">
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="about_salsa.html"><strong aria-hidden="true">1.</strong> About salsa</a></li><li><a href="how_to_use.html"><strong aria-hidden="true">2.</strong> How to use Salsa</a></li><li><a href="how_salsa_works.html"><strong aria-hidden="true">3.</strong> How Salsa works</a></li><li><a href="common_patterns.html"><strong aria-hidden="true">4.</strong> Common patterns</a></li><li><ol class="section"><li><a href="common_patterns/selection.html"><strong aria-hidden="true">4.1.</strong> Selection</a></li><li><a href="common_patterns/on_demand_inputs.html"><strong aria-hidden="true">4.2.</strong> On-demand (Lazy) inputs</a></li></ol></li><li><a href="videos.html"><strong aria-hidden="true">5.</strong> YouTube videos</a></li><li><a href="plumbing.html"><strong aria-hidden="true">6.</strong> Plumbing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Salsa</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#about-salsa" id="about-salsa">About salsa</a></h1>
<p>Salsa is a Rust framework for writing incremental, on-demand programs
-- these are programs that want to adapt to changes in their inputs,
continuously producing a new output that is up-to-date. Salsa is based
on the the incremental recompilation techniques that we built for
rustc, and many (but not all) of its users are building compilers or
other similar tooling.</p>
<p>If you'd like to learn more about Salsa, you can check out the
<a href="https://github.com/salsa-rs/salsa/blob/master/examples/hello_world/main.rs">Hello World example</a>
in the repository, or watch some of our <a href="./videos.html">YouTube videos</a>.</p>
<p>If you'd like to chat about Salsa, or you think you might like to
contribute, please jump on to our Zulip instance at
<a href="https://salsa.zulipchat.com/">salsa.zulipchat.com</a>.</p>
<h1><a class="header" href="#how-to-use-salsa" id="how-to-use-salsa">How to use Salsa</a></h1>
<h1><a class="header" href="#how-salsa-works" id="how-salsa-works">How Salsa works</a></h1>
<h2><a class="header" href="#video-available" id="video-available">Video available</a></h2>
<p>To get the most complete introduction to Salsa's inner works, check
out <a href="https://youtu.be/_muY4HjSqVw">the &quot;How Salsa Works&quot; video</a>.  If
you'd like a deeper dive, <a href="https://www.youtube.com/watch?v=i_IhACacPRY">the &quot;Salsa in more depth&quot;
video</a> digs into the
details of the incremental algorithm.</p>
<h2><a class="header" href="#key-idea" id="key-idea">Key idea</a></h2>
<p>The key idea of <code>salsa</code> is that you define your program as a set of
<strong>queries</strong>. Every query is used like function <code>K -&gt; V</code> that maps from
some key of type <code>K</code> to a value of type <code>V</code>. Queries come in two basic
varieties:</p>
<ul>
<li><strong>Inputs</strong>: the base inputs to your system. You can change these
whenever you like.</li>
<li><strong>Functions</strong>: pure functions (no side effects) that transform your
inputs into other values. The results of queries is memoized to
avoid recomputing them a lot. When you make changes to the inputs,
we'll figure out (fairly intelligently) when we can re-use these
memoized values and when we have to recompute them.</li>
</ul>
<h2><a class="header" href="#how-to-use-salsa-in-three-easy-steps" id="how-to-use-salsa-in-three-easy-steps">How to use Salsa in three easy steps</a></h2>
<p>Using salsa is as easy as 1, 2, 3...</p>
<ol>
<li>Define one or more <strong>query groups</strong> that contain the inputs
and queries you will need. We'll start with one such group, but
later on you can use more than one to break up your system into
components (or spread your code across crates).</li>
<li>Define the <strong>query functions</strong> where appropriate.</li>
<li>Define the <strong>database</strong>, which contains the storage for all
the inputs/queries you will be using. The query struct will contain
the storage for all of the inputs/queries and may also contain
anything else that your code needs (e.g., configuration data).</li>
</ol>
<p>To see an example of this in action, check out <a href="https://github.com/salsa-rs/salsa/blob/master/examples/hello_world/main.rs">the <code>hello_world</code>
example</a>, which has a number of comments explaining how
things work.</p>
<h1><a class="header" href="#common-patterns" id="common-patterns">Common patterns</a></h1>
<p>This section documents patterns for using Salsa.</p>
<h1><a class="header" href="#selection" id="selection">Selection</a></h1>
<p>The &quot;selection&quot; (or &quot;firewall&quot;) pattern is when you have a query Qsel that reads from some
other Qbase and extracts some small bit of information from Qbase that it returns.
In particular, Qsel does not combine values from other queries. In some sense,
then, Qsel is redundant -- you could have just extracted the information
the information from Qbase yourself, and done without the salsa machinery. But
Qsel serves a role in that it limits the amount of re-execution that is required
when Qbase changes.</p>
<h2><a class="header" href="#example-the-base-query" id="example-the-base-query">Example: the base query</a></h2>
<p>For example, imagine that you have a query <code>parse</code> that parses the input text of a request
and returns a <code>ParsedResult</code>, which contains a header and a body:</p>
<pre><code class="language-rust ignore">#[derive(Clone, Debug, PartialEq, Eq)]
struct ParsedResult {
    header: Vec&lt;ParsedHeader&gt;,
    body: String,
}

#[derive(Clone, Debug, PartialEq, Eq)]
struct ParsedHeader {
    key: String,
    value: String,
}

#[salsa::query_group(Request)]
trait RequestParser {
    /// The base text of the request.
    #[salsa::input]
    fn request_text(&amp;self) -&gt; String;

    /// The parsed form of the request.
    fn parse(&amp;self) -&gt; ParsedResult;
} 
</code></pre>
<h2><a class="header" href="#example-a-selecting-query" id="example-a-selecting-query">Example: a selecting query</a></h2>
<p>And now you have a number of derived queries that only look at the header.
For example, one might extract the &quot;content-type' header:</p>
<pre><code class="language-rust ignore">#[salsa::query_group(Request)]
trait RequestUtil: RequestParser {
    fn content_type(&amp;self) -&gt; Option&lt;String&gt;;
}

fn content_type(db: &amp;impl RequestUtil) -&gt; Option&lt;String&gt; {
    db.parse()
        .header
        .iter()
        .find(|header| header.key == &quot;content-type&quot;)
        .map(|header| header.value.clone())
} 
</code></pre>
<h2><a class="header" href="#why-prefer-a-selecting-query" id="why-prefer-a-selecting-query">Why prefer a selecting query?</a></h2>
<p>This <code>content_type</code> query is an instance of the <em>selection</em> pattern. It only
&quot;selects&quot; a small bit of information from the <code>ParsedResult</code>. You might not have
made it a query at all, but instead made it a method on <code>ParsedResult</code>.</p>
<p>But using a query for <code>content_type</code> has an advantage: now if there are downstream
queries that only depend on the <code>content_type</code> (or perhaps on other headers extracted
via a similar pattern), those queries will not have to be re-executed when the request
changes <em>unless</em> the content-type header changes. Consider the dependency graph:</p>
<pre><code class="language-text">request_text  --&gt;  parse  --&gt;  content_type  --&gt;  (other queries)
</code></pre>
<p>When the <code>request_text</code> changes, we are always going to have to re-execute <code>parse</code>.
If that produces a new parsed result, we are <em>also</em> going to re-execute <code>content_type</code>.
But if the result of <code>content_type</code> has not changed, then we will <em>not</em> re-execute
the other queries.</p>
<h2><a class="header" href="#more-levels-of-selection" id="more-levels-of-selection">More levels of selection</a></h2>
<p>In fact, in our example we might consider introducing another level of selection.
Instead of having <code>content_type</code> directly access the results of <code>parse</code>, it might be better
to insert a selecting query that just extracts the header:</p>
<pre><code class="language-rust ignore">#[salsa::query_group(Request)]
trait RequestUtil: RequestParser {
    fn header(&amp;self) -&gt; Vec&lt;ParsedHeader&gt;;
    fn content_type(&amp;self) -&gt; Option&lt;String&gt;;
}

fn header(db: &amp;impl RequestUtil) -&gt; Vec&lt;ParsedHeader&gt; {
    db.parse().header.clone()
}

fn content_type(db: &amp;impl RequestUtil) -&gt; Option&lt;String&gt; {
    db.header()
        .iter()
        .find(|header| header.key == &quot;content-type&quot;)
        .map(|header| header.value.clone())
} 
</code></pre>
<p>This will result in a dependency graph like so:</p>
<pre><code class="language-text">request_text  --&gt;  parse  --&gt;  header --&gt;  content_type  --&gt;  (other queries)
</code></pre>
<p>The advantage of this is that changes that only effect the &quot;body&quot; or
only consume small parts of the request will
not require us to re-execute <code>content_type</code> at all. This would be particularly
valuable if there are a lot of dependent headers.</p>
<h2><a class="header" href="#a-note-on-cloning-and-efficiency" id="a-note-on-cloning-and-efficiency">A note on cloning and efficiency</a></h2>
<p>In this example, we used common Rust types like <code>Vec</code> and <code>String</code>,
and we cloned them quite frequently. This will work just fine in Salsa,
but it may not be the most efficient choice. This is because each clone
is going to produce a deep copy of the result. As a simple fix, you
might convert your data structures to use <code>Arc</code> (e.g., <code>Arc&lt;Vec&lt;ParsedHeader&gt;&gt;</code>),
which makes cloning cheap.</p>
<h1><a class="header" href="#on-demand-lazy-inputs" id="on-demand-lazy-inputs">On-Demand (Lazy) Inputs</a></h1>
<p>Salsa input queries work best if you can easily provide all of the inputs upfront.
However sometimes the set of inputs is not known beforehand.</p>
<p>A typical example is reading files from disk.
While it is possible to eagerly scan a particular directory and create an in-memory file tree in a salsa input query, a more straight-forward approach is to read the files lazily.
That is, when someone requests the text of a file for the first time:</p>
<ol>
<li>Read the file from disk and cache it.</li>
<li>Setup a file-system watcher for this path.</li>
<li>Invalidate the cached file once the watcher sends a change notification.</li>
</ol>
<p>This is possible to achieve in salsa, using a derived query and <code>report_synthetic_read</code> and <code>invalidate</code> queries.
The setup looks roughly like this:</p>
<pre><code class="language-rust ignore">#[salsa::query_group(VfsDatabaseStorage)]
trait VfsDatabase: salsa::Database + FileWatcher {
    fn read(&amp;self, path: PathBuf) -&gt; String;
}

trait FileWatcher {
    fn watch(&amp;self, path: &amp;Path);
    fn did_change_file(&amp;mut self, path: &amp;Path);
}

fn read(db: &amp;impl salsa::Database, path: PathBuf) -&gt; String {
    db.salsa_runtime()
        .report_synthetic_read(salsa::Durability::LOW);
    db.watch(&amp;path);
    std::fs::read_to_string(&amp;path).unwrap_or_default()
}

#[salsa::database(VfsDatabaseStorage)]
struct MyDatabase { ... }

impl FileWatcher for MyDatabase {
    fn watch(&amp;self, path: &amp;Path) { ... }
    fn did_change_file(&amp;mut self, path: &amp;Path) {
        self.query_mut(ReadQuery).invalidate(path);
    }
}
</code></pre>
<ul>
<li>We declare the query as a derived query (which is the default).</li>
<li>In the query implementation, we don't call any other query and just directly read file from disk.</li>
<li>Because the query doesn't read any inputs, it will be assigned a <code>HIGH</code> durability by default, which we override with <code>report_synthetic_read</code>.</li>
<li>The result of the query is cached, and we must call <code>invalidate</code> to clear this cache.</li>
</ul>
<h1><a class="header" href="#youtube-videos" id="youtube-videos">YouTube videos</a></h1>
<p>There are currently two videos about Salsa available:</p>
<ul>
<li><a href="https://youtu.be/_muY4HjSqVw">How Salsa Works</a>, which gives a
high-level introduction to the key concepts involved and shows how
to use salsa;</li>
<li><a href="https://www.youtube.com/watch?v=i_IhACacPRY">Salsa In More Depth</a>,
which digs into the incremental algorithm and explains -- at a
high-level -- how Salsa is implemented.</li>
</ul>
<h1><a class="header" href="#plumbing" id="plumbing">Plumbing</a></h1>
<p><strong>Last updated:</strong> 2020-06-24</p>
<p>This chapter documents the code that salsa generates and its &quot;inner workings&quot;.
We refer to this as the &quot;plumbing&quot;.</p>
<p>This page walks through the <a href="https://github.com/salsa-rs/salsa/blob/master/examples/hello_world/main.rs">&quot;Hello, World!&quot;</a> example and explains the code that
it generates. Please take it with a grain of salt: while we make an effort to
keep this documentation up to date, this sort of thing can fall out of date
easily.</p>
<p>If you'd like to see for yourself, you can set the environment variable
<code>SALSA_DUMP</code> to 1 while the procedural macro runs, and it will dump the full
output to stdout. I recommend piping the output through rustfmt.</p>
<h2><a class="header" href="#query-groups-and-query-group-structs" id="query-groups-and-query-group-structs">Query groups and query group structs</a></h2>
<p>When you define a query group trait:</p>
<pre><code class="language-rust ignore">#[salsa::query_group(HelloWorldStorage)]
trait HelloWorld: salsa::Database {
    // For each query, we give the name, some input keys (here, we
    // have one key, `()`) and the output type `Arc&lt;String&gt;`. We can
    // use attributes to give other configuration:
    //
    // - `salsa::input` indicates that this is an &quot;input&quot; to the system,
    //   which must be explicitly set. The `salsa::query_group` method
    //   will autogenerate a `set_input_string` method that can be
    //   used to set the input.
    #[salsa::input]
    fn input_string(&amp;self, key: ()) -&gt; Arc&lt;String&gt;;

    // This is a *derived query*, meaning its value is specified by
    // a function (see Step 2, below).
    fn length(&amp;self, key: ()) -&gt; usize;
}
</code></pre>
<p>the <code>salsa::query_group</code> macro generates a number of things:</p>
<ul>
<li>a copy of the <code>HelloWorld</code> trait, minus the salsa annotations, and lightly edited</li>
<li>a &quot;group struct&quot; named <code>HelloWorldStorage</code> that represents the group; this struct implements <code>plumbing::QueryGroup</code>
<ul>
<li>somewhat confusingly, this struct doesn't actually contain the storage itself, but rather has an associated type that leads to the &quot;true&quot; storage struct</li>
</ul>
</li>
<li>an impl of the <code>HelloWorld</code> trait, for any database type</li>
<li>for each query, a &quot;query struct&quot; named after the query; these structs implement <code>plumbing::Query</code> and sometimes other plumbing traits</li>
<li>a group key, an enum that can identify any query within the group and store its key</li>
<li>the associated storage struct, which contains the actual hashmaps that store the data for all queries in the group</li>
</ul>
<p>Note that there are a number of structs and types (e.g., the group descriptor
and associated storage struct) that represent things which don't have &quot;public&quot;
names. We currently generate mangled names with <code>__</code> afterwards, but those names
are not meant to be exposed to the user (ideally we'd use hygiene to enforce
this).</p>
<p>So the generated code looks something like this. We'll go into more detail on
each part in the following sections.</p>
<pre><code class="language-rust ignore">// First, a copy of the trait, though sometimes with some extra
// methods (e.g., `set_input_string`)
trait HelloWorld: salsa::Database {
    fn input_string(&amp;self, key: ()) -&gt; Arc&lt;String&gt;;
    fn set_input_string(&amp;mut self, key: (), value: Arc&lt;String&gt;);
    fn length(&amp;self, key: ()) -&gt; usize;
}

// Next, the group struct
struct HelloWorldStorage { }
impl&lt;DB&gt; salsa::plumbing::QueryGroup&lt;DB&gt; for HelloWorldStorage { ... }

// Next, the impl of the trait
impl&lt;DB&gt; HelloWorld for DB
where
  DB: salsa::Database,
  DB: salsa::plumbing::HasQueryGroup&lt;HelloWorldStorage&gt;,
{
  ...
}

// Next, a series of query structs and query impls
struct InputQuery { }
unsafe impl&lt;DB&gt; salsa::Query&lt;DB&gt; for InputQuery
where
    DB: HelloWorld,
    DB: salsa::plumbing::HasQueryGroup&lt;#group_struct&gt;,
    DB: salsa::Database,
{
    ...
}
struct LengthQuery { }
unsafe impl&lt;DB&gt; salsa::Query&lt;DB&gt; for LengthQuery
where
    DB: HelloWorld,
    DB: salsa::plumbing::HasQueryGroup&lt;#group_struct&gt;,
    DB: salsa::Database,
{
    ...
}

// For derived queries, those include implementations
// of additional traits like `QueryFunction`
unsafe impl&lt;DB&gt; salsa::QueryFunction&lt;DB&gt; for LengthQuery
where
    DB: HelloWorld,
    DB: salsa::plumbing::HasQueryGroup&lt;#group_struct&gt;,
    DB: salsa::Database,
{
    ...
}

// The group key
enum HelloWorldGroupKey__ { .. }

// The group storage
struct HelloWorldGroupStorage__ { .. }
</code></pre>
<h3><a class="header" href="#the-group-struct-and-querygroup-trait" id="the-group-struct-and-querygroup-trait">The group struct and <code>QueryGroup</code> trait</a></h3>
<p>The group struct is the only thing we generate whose name is known to the user.
For a query group named <code>Foo</code>, it is conventionally called <code>FooStorage</code>, hence
the name <code>HelloWorldStorage</code> in our example.</p>
<p>Despite the name &quot;Storage&quot;, the struct itself has no fields. It exists only to
implement the <code>QueryGroup</code> trait. This <em>trait</em> has a number of associated types
that reference various bits of the query group, including the actual &quot;group
storage&quot; struct:</p>
<pre><code class="language-rust ignore">struct HelloWorldStorage { }
impl&lt;DB&gt; salsa::plumbing::QueryGroup&lt;DB&gt; for HelloWorldStorage {
    type GroupStorage = HelloWorldGroupStorage__; // generated struct
    type GroupKey = HelloWorldGroupKey__;
    type GroupData = ((), Arc&lt;String&gt;, (), usize);
}
</code></pre>
<p>We'll go into detail on these types below and the role they play, but one that
we didn't mention yet is <code>GroupData</code>. That is a kind of hack used to manage
send/sync around slots, and it gets covered in the section on slots.</p>
<h3><a class="header" href="#impl-of-the-hello-world-trait" id="impl-of-the-hello-world-trait">Impl of the hello world trait</a></h3>
<p>Ultimately, every salsa query group is going to be implemented by your final
database type, which is not currently known to us (it is created by combining
multiple salsa query groups). In fact, this salsa query group could be composed
into multiple database types. However, we want to generate the impl of the query-group
trait here in this crate, because this is the point where the trait definition is visible
and known to us (otherwise, we'd have to duplicate the method definitions).</p>
<p>So what we do is that we define a different trait, called <code>plumbing::HasQueryGroup&lt;G&gt;</code>,
that can be implemented by the database type. <code>HasQueryGroup</code> is generic over
the query group struct. So then we can provide an impl of <code>HelloWorld</code> for any
database type <code>DB</code> where <code>DB: HasQueryGroup&lt;HelloWorldStorage&gt;</code>. This
<code>HasQueryGroup</code> defines a few methods that, given a <code>DB</code>, give access to the
data for the query group and a few other things.</p>
<p>Thus we can generate an impl that looks like:</p>
<pre><code class="language-rust ignore">impl&lt;DB&gt; HelloWorld for DB
where
    DB: salsa::Database,
    DB: salsa::plumbing::HasQueryGroup&lt;HelloWorld&gt;
{
    ...
    fn length(&amp;self, key: ()) -&gt; Arc&lt;String&gt; {
      &lt;Self as salsa::plumbing::GetQueryTable&lt;HelloWorldLength__&gt;&gt;::get_query_table(self).get(())
    }
}
</code></pre>
<p>You can see that the various methods just hook into generic functions in the
<code>salsa::plumbing</code> module. These functions are generic over the query types
(<code>HelloWorldLength__</code>) that will be described shortly. The details of the &quot;query
table&quot; are covered in a future section, but in short this code pulls out the
hasmap for storing the <code>length</code> results and invokes the generic salsa logic to
check for a valid result, etc.</p>
<h3><a class="header" href="#for-each-query-a-query-struct" id="for-each-query-a-query-struct">For each query, a query struct</a></h3>
<p>As we referenced in the previous section, each query in the trait gets a struct
that represents it. This struct is named after the query, converted into snake
case and with the word <code>Query</code> appended. In typical Salsa workflows, these
structs are not meant to be named or used, but in some cases it may be required.
For e.g. the <code>length</code> query, this structs might look something like:</p>
<pre><code class="language-rust ignore">struct LengthQuery { }
</code></pre>
<p>The struct also implements the <code>plumbing::Query</code> trait, which defines
a bunch of metadata about the query (and repeats, for convenience,
some of the data about the group that the query is in):</p>
<pre><code class="language-rust ignore">unsafe impl&lt;DB&gt; salsa::Query&lt;DB&gt; for LengthQuery
where
    DB: HelloWorld,
    DB: salsa::plumbing::HasQueryGroup&lt;#group_struct&gt;,
    DB: salsa::Database,
{
    // A tuple of the types of the function parameters trom trait.
    type Key = ((), );

    // The return value of the function in the trait.
    type Value = Arc&lt;String&gt;;

    // The &quot;query storage&quot; references a type from within salsa
    // that stores the actual query data and defines the
    // logic for accessing and revalidating it.
    //
    // It is generic over the query type which lets it
    // customize itself to the keys/value of this particular
    // query.
    type Storage = salsa::derived::DerivedStorage&lt;
        DB,
        LengthQuery,
        salsa::plumbing::MemoizedStorage,
    &gt;;

    // Types from the query group, repeated for convenience.
    type Group = HelloWorldStorage;
    type GroupStorage = HelloWorldGroupStorage__;
    type GroupKey = HelloWorldGroupKey__;

    // Given the storage for the entire group, extract
    // the storage for just this query. Described when
    // we talk about group storage.
    fn query_storage(
        group_storage: &amp;HelloWorldGroupStorage__,
    ) -&gt; &amp;std::sync::Arc&lt;Self::Storage&gt; {
        &amp;group_storage.length
    }

    // Given the key for this query, construct the &quot;group key&quot;
    // that situates it within the group. Described when
    // we talk about group key.
    fn group_key(key: Self::Key) -&gt; Self::GroupKey {
        HelloWorldGroupKey__::length(key)
    }
}
</code></pre>
<p>Depending on the kind of query, we may also generate other impls, such as an
impl of <code>salsa::plumbing::QueryFunction</code>, which defines the methods for
executing the body of a query. This impl would then include a call to the user's
actual function.</p>
<h3><a class="header" href="#group-key" id="group-key">Group key</a></h3>
<p>The &quot;query key&quot; is the inputs to the query, and identifies a particular query
instace: in our example, it is a value of type <code>()</code> (so there is only one
instance of the query), but typically it's some other type. The &quot;group key&quot; then
broadens that to include the identifier of the query within the group. So instead
of just <code>()</code> the group key would encode (e.g.) <code>Length(())</code> (the &quot;length&quot; query
applied to the <code>()</code> key). It is represented as an enum, which we generate,
with one variant per query:</p>
<pre><code class="language-rust ignore">#[derive(Clone, Debug, PartialEq, Eq, Hash)]
enum HelloWorldGroupKey__ {
  input(()),
  length(()),
}
</code></pre>
<p>The <code>Query</code> trait that we saw earlier includes a method <code>group_key</code> for wrapping
the key for some individual query into the group key.</p>
<h3><a class="header" href="#group-storege" id="group-storege">Group storege</a></h3>
<p>The &quot;group storage&quot; is the actual struct that contains all the hashtables and
so forth for each query. The types of these are ultimately defined by the
<code>Storage</code> associated type for each query type. The struct is generic over the
final database type:</p>
<pre><code class="language-rust ignore">struct HelloWorldGroupStorage__&lt;DB&gt; {
    input: &lt;InputQuery as Query&lt;DB&gt;&gt;::Storage,
    length: &lt;LengthQuery as Query&lt;DB&gt;&gt;::Storage,
}
</code></pre>
<p>We also generate some impls: first is an impl of <code>Default</code> and the second is a
method <code>for_each_query</code> that simply iterates over each field and invokes a
method on it. This method is called by some of the code we generate for the
database in order to implement debugging methods that &quot;sweep&quot; over all the
queries.</p>
<pre><code class="language-rust ignore">impl&lt;DB&gt; HelloWorldGroupStorage__&lt;DB&gt; {
    fn for_each_query(&amp;self, db: &amp;DB, method: &amp;mut dyn FnMut(...)) {
        ...
    }
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="mermaid.min.js"></script>
        
        <script type="text/javascript" src="mermaid-init.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
